/*
 * Module code.
 *
 * Generated by SIP 4.19.7
 */

#include "sipAPIPyKDL.h"

#line 529 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainiksolvervel_pinv_nso.hpp>
using namespace KDL;
#line 13 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"

#line 133 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 18 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"
#line 172 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 22 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"
#line 281 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 28 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"


class sipChainIkSolverVel_pinv_nso : public  ::ChainIkSolverVel_pinv_nso
{
public:
    sipChainIkSolverVel_pinv_nso(const  ::Chain&,double,int,double);
    sipChainIkSolverVel_pinv_nso(const  ::ChainIkSolverVel_pinv_nso&);
    virtual ~sipChainIkSolverVel_pinv_nso();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    int setAlpha(const double);
    int setOptPos(const  ::JntArray&);
    int setWeights(const  ::JntArray&);
    void updateInternalDataStructures();
    int CartToJnt(const  ::JntArray&,const  ::Twist&, ::JntArray&);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipChainIkSolverVel_pinv_nso(const sipChainIkSolverVel_pinv_nso &);
    sipChainIkSolverVel_pinv_nso &operator = (const sipChainIkSolverVel_pinv_nso &);

    char sipPyMethods[5];
};

sipChainIkSolverVel_pinv_nso::sipChainIkSolverVel_pinv_nso(const  ::Chain& a0,double a1,int a2,double a3):  ::ChainIkSolverVel_pinv_nso(a0,a1,a2,a3), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverVel_pinv_nso::sipChainIkSolverVel_pinv_nso(const  ::ChainIkSolverVel_pinv_nso& a0):  ::ChainIkSolverVel_pinv_nso(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverVel_pinv_nso::~sipChainIkSolverVel_pinv_nso()
{
    sipInstanceDestroyed(sipPySelf);
}

int sipChainIkSolverVel_pinv_nso::setAlpha(const double a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_setAlpha);

    if (!sipMeth)
        return  ::ChainIkSolverVel_pinv_nso::setAlpha(a0);

    extern int sipVH_PyKDL_9(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const double);

    return sipVH_PyKDL_9(sipGILState, 0, sipPySelf, sipMeth, a0);
}

int sipChainIkSolverVel_pinv_nso::setOptPos(const  ::JntArray& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,NULL,sipName_setOptPos);

    if (!sipMeth)
        return  ::ChainIkSolverVel_pinv_nso::setOptPos(a0);

    extern int sipVH_PyKDL_8(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::JntArray&);

    return sipVH_PyKDL_8(sipGILState, 0, sipPySelf, sipMeth, a0);
}

int sipChainIkSolverVel_pinv_nso::setWeights(const  ::JntArray& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[2],sipPySelf,NULL,sipName_setWeights);

    if (!sipMeth)
        return  ::ChainIkSolverVel_pinv_nso::setWeights(a0);

    extern int sipVH_PyKDL_8(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::JntArray&);

    return sipVH_PyKDL_8(sipGILState, 0, sipPySelf, sipMeth, a0);
}

void sipChainIkSolverVel_pinv_nso::updateInternalDataStructures()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[3],sipPySelf,NULL,sipName_updateInternalDataStructures);

    if (!sipMeth)
    {
         ::ChainIkSolverVel_pinv_nso::updateInternalDataStructures();
        return;
    }

    extern void sipVH_PyKDL_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH_PyKDL_2(sipGILState, 0, sipPySelf, sipMeth);
}

int sipChainIkSolverVel_pinv_nso::CartToJnt(const  ::JntArray& a0,const  ::Twist& a1, ::JntArray& a2)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[4],sipPySelf,NULL,sipName_CartToJnt);

    if (!sipMeth)
        return  ::ChainIkSolverVel_pinv_nso::CartToJnt(a0,a1,a2);

    extern int sipVH_PyKDL_6(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::JntArray&,const  ::Twist&, ::JntArray&);

    return sipVH_PyKDL_6(sipGILState, 0, sipPySelf, sipMeth, a0, a1, a2);
}


PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_nso_CartToJnt, "CartToJnt(self, q_in: JntArray, v_in: Twist, qdot_out: JntArray) -> int");

extern "C" {static PyObject *meth_ChainIkSolverVel_pinv_nso_CartToJnt(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_pinv_nso_CartToJnt(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::JntArray* a0;
        const  ::Twist* a1;
         ::JntArray* a2;
         ::ChainIkSolverVel_pinv_nso *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q_in,
            sipName_v_in,
            sipName_qdot_out,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9J9J9", &sipSelf, sipType_ChainIkSolverVel_pinv_nso, &sipCpp, sipType_JntArray, &a0, sipType_Twist, &a1, sipType_JntArray, &a2))
        {
            int sipRes;

            sipRes = (sipSelfWasArg ? sipCpp-> ::ChainIkSolverVel_pinv_nso::CartToJnt(*a0,*a1,*a2) : sipCpp->CartToJnt(*a0,*a1,*a2));

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_pinv_nso, sipName_CartToJnt, doc_ChainIkSolverVel_pinv_nso_CartToJnt);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_nso_updateInternalDataStructures, "updateInternalDataStructures(self)");

extern "C" {static PyObject *meth_ChainIkSolverVel_pinv_nso_updateInternalDataStructures(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_pinv_nso_updateInternalDataStructures(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::ChainIkSolverVel_pinv_nso *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainIkSolverVel_pinv_nso, &sipCpp))
        {
            (sipSelfWasArg ? sipCpp-> ::ChainIkSolverVel_pinv_nso::updateInternalDataStructures() : sipCpp->updateInternalDataStructures());

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_pinv_nso, sipName_updateInternalDataStructures, doc_ChainIkSolverVel_pinv_nso_updateInternalDataStructures);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_nso_setWeights, "setWeights(self, weights: JntArray) -> int");

extern "C" {static PyObject *meth_ChainIkSolverVel_pinv_nso_setWeights(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_pinv_nso_setWeights(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::JntArray* a0;
         ::ChainIkSolverVel_pinv_nso *sipCpp;

        static const char *sipKwdList[] = {
            sipName_weights,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_ChainIkSolverVel_pinv_nso, &sipCpp, sipType_JntArray, &a0))
        {
            int sipRes;

            sipRes = (sipSelfWasArg ? sipCpp-> ::ChainIkSolverVel_pinv_nso::setWeights(*a0) : sipCpp->setWeights(*a0));

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_pinv_nso, sipName_setWeights, doc_ChainIkSolverVel_pinv_nso_setWeights);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_nso_setOptPos, "setOptPos(self, opt_pos: JntArray) -> int");

extern "C" {static PyObject *meth_ChainIkSolverVel_pinv_nso_setOptPos(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_pinv_nso_setOptPos(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::JntArray* a0;
         ::ChainIkSolverVel_pinv_nso *sipCpp;

        static const char *sipKwdList[] = {
            sipName_opt_pos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_ChainIkSolverVel_pinv_nso, &sipCpp, sipType_JntArray, &a0))
        {
            int sipRes;

            sipRes = (sipSelfWasArg ? sipCpp-> ::ChainIkSolverVel_pinv_nso::setOptPos(*a0) : sipCpp->setOptPos(*a0));

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_pinv_nso, sipName_setOptPos, doc_ChainIkSolverVel_pinv_nso_setOptPos);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_nso_setAlpha, "setAlpha(self, alpha: float) -> int");

extern "C" {static PyObject *meth_ChainIkSolverVel_pinv_nso_setAlpha(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_pinv_nso_setAlpha(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        double a0;
         ::ChainIkSolverVel_pinv_nso *sipCpp;

        static const char *sipKwdList[] = {
            sipName_alpha,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bd", &sipSelf, sipType_ChainIkSolverVel_pinv_nso, &sipCpp, &a0))
        {
            int sipRes;

            sipRes = (sipSelfWasArg ? sipCpp-> ::ChainIkSolverVel_pinv_nso::setAlpha(a0) : sipCpp->setAlpha(a0));

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_pinv_nso, sipName_setAlpha, doc_ChainIkSolverVel_pinv_nso_setAlpha);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_nso_getWeights, "getWeights(self) -> JntArray");

extern "C" {static PyObject *meth_ChainIkSolverVel_pinv_nso_getWeights(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_pinv_nso_getWeights(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::ChainIkSolverVel_pinv_nso *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainIkSolverVel_pinv_nso, &sipCpp))
        {
             ::JntArray*sipRes;

            sipRes = new  ::JntArray(sipCpp->getWeights());

            return sipConvertFromNewType(sipRes,sipType_JntArray,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_pinv_nso, sipName_getWeights, doc_ChainIkSolverVel_pinv_nso_getWeights);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_nso_getOptPos, "getOptPos(self) -> JntArray");

extern "C" {static PyObject *meth_ChainIkSolverVel_pinv_nso_getOptPos(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_pinv_nso_getOptPos(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::ChainIkSolverVel_pinv_nso *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainIkSolverVel_pinv_nso, &sipCpp))
        {
             ::JntArray*sipRes;

            sipRes = new  ::JntArray(sipCpp->getOptPos());

            return sipConvertFromNewType(sipRes,sipType_JntArray,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_pinv_nso, sipName_getOptPos, doc_ChainIkSolverVel_pinv_nso_getOptPos);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_nso_getAlpha, "getAlpha(self) -> float");

extern "C" {static PyObject *meth_ChainIkSolverVel_pinv_nso_getAlpha(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_pinv_nso_getAlpha(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::ChainIkSolverVel_pinv_nso *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainIkSolverVel_pinv_nso, &sipCpp))
        {
            double sipRes;

            sipRes = sipCpp->getAlpha();

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_pinv_nso, sipName_getAlpha, doc_ChainIkSolverVel_pinv_nso_getAlpha);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_ChainIkSolverVel_pinv_nso(void *, const sipTypeDef *);}
static void *cast_ChainIkSolverVel_pinv_nso(void *sipCppV, const sipTypeDef *targetType)
{
     ::ChainIkSolverVel_pinv_nso *sipCpp = reinterpret_cast< ::ChainIkSolverVel_pinv_nso *>(sipCppV);

    if (targetType == sipType_ChainIkSolverVel)
        return static_cast< ::ChainIkSolverVel *>(sipCpp);

    if (targetType == sipType_SolverI)
        return static_cast< ::SolverI *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_ChainIkSolverVel_pinv_nso(void *, int);}
static void release_ChainIkSolverVel_pinv_nso(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipChainIkSolverVel_pinv_nso *>(sipCppV);
    else
        delete reinterpret_cast< ::ChainIkSolverVel_pinv_nso *>(sipCppV);
}


extern "C" {static void dealloc_ChainIkSolverVel_pinv_nso(sipSimpleWrapper *);}
static void dealloc_ChainIkSolverVel_pinv_nso(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipChainIkSolverVel_pinv_nso *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_ChainIkSolverVel_pinv_nso(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_ChainIkSolverVel_pinv_nso(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_ChainIkSolverVel_pinv_nso(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipChainIkSolverVel_pinv_nso *sipCpp = 0;

    {
        const  ::Chain* a0;
        double a1 = 1e-05;
        int a2 = 150;
        double a3 = 0.25;

        static const char *sipKwdList[] = {
            sipName_chain,
            sipName_eps,
            sipName_maxiter,
            sipName_alpha,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9|did", sipType_Chain, &a0, &a1, &a2, &a3))
        {
            sipCpp = new sipChainIkSolverVel_pinv_nso(*a0,a1,a2,a3);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::ChainIkSolverVel_pinv_nso* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_ChainIkSolverVel_pinv_nso, &a0))
        {
            sipCpp = new sipChainIkSolverVel_pinv_nso(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_ChainIkSolverVel_pinv_nso[] = {{10, 255, 1}};


static PyMethodDef methods_ChainIkSolverVel_pinv_nso[] = {
    {SIP_MLNAME_CAST(sipName_CartToJnt), (PyCFunction)meth_ChainIkSolverVel_pinv_nso_CartToJnt, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_pinv_nso_CartToJnt)},
    {SIP_MLNAME_CAST(sipName_getAlpha), meth_ChainIkSolverVel_pinv_nso_getAlpha, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_pinv_nso_getAlpha)},
    {SIP_MLNAME_CAST(sipName_getOptPos), meth_ChainIkSolverVel_pinv_nso_getOptPos, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_pinv_nso_getOptPos)},
    {SIP_MLNAME_CAST(sipName_getWeights), meth_ChainIkSolverVel_pinv_nso_getWeights, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_pinv_nso_getWeights)},
    {SIP_MLNAME_CAST(sipName_setAlpha), (PyCFunction)meth_ChainIkSolverVel_pinv_nso_setAlpha, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_pinv_nso_setAlpha)},
    {SIP_MLNAME_CAST(sipName_setOptPos), (PyCFunction)meth_ChainIkSolverVel_pinv_nso_setOptPos, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_pinv_nso_setOptPos)},
    {SIP_MLNAME_CAST(sipName_setWeights), (PyCFunction)meth_ChainIkSolverVel_pinv_nso_setWeights, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_pinv_nso_setWeights)},
    {SIP_MLNAME_CAST(sipName_updateInternalDataStructures), meth_ChainIkSolverVel_pinv_nso_updateInternalDataStructures, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_pinv_nso_updateInternalDataStructures)}
};

PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_nso, "\1ChainIkSolverVel_pinv_nso(chain: Chain, eps: float = 1e-05, maxiter: int = 150, alpha: float = 0.25)\n"
"ChainIkSolverVel_pinv_nso(ChainIkSolverVel_pinv_nso)");


sipClassTypeDef sipTypeDef_PyKDL_ChainIkSolverVel_pinv_nso = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_ChainIkSolverVel_pinv_nso,
        {0},
        0
    },
    {
        sipNameNr_ChainIkSolverVel_pinv_nso,
        {0, 0, 1},
        8, methods_ChainIkSolverVel_pinv_nso,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_ChainIkSolverVel_pinv_nso,
    -1,
    -1,
    supers_ChainIkSolverVel_pinv_nso,
    0,
    init_type_ChainIkSolverVel_pinv_nso,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_ChainIkSolverVel_pinv_nso,
    0,
    0,
    0,
    release_ChainIkSolverVel_pinv_nso,
    cast_ChainIkSolverVel_pinv_nso,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 515 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainiksolverpos_lma.hpp>
using namespace KDL;
#line 563 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"

#line 133 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 568 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"
#line 172 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 572 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"
#line 201 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 578 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"


class sipChainIkSolverPos_LMA : public  ::ChainIkSolverPos_LMA
{
public:
    sipChainIkSolverPos_LMA(const  ::Chain&,double,int,double);
    sipChainIkSolverPos_LMA(const  ::ChainIkSolverPos_LMA&);
    virtual ~sipChainIkSolverPos_LMA();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void updateInternalDataStructures();
    int CartToJnt(const  ::JntArray&,const  ::Frame&, ::JntArray&);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipChainIkSolverPos_LMA(const sipChainIkSolverPos_LMA &);
    sipChainIkSolverPos_LMA &operator = (const sipChainIkSolverPos_LMA &);

    char sipPyMethods[2];
};

sipChainIkSolverPos_LMA::sipChainIkSolverPos_LMA(const  ::Chain& a0,double a1,int a2,double a3):  ::ChainIkSolverPos_LMA(a0,a1,a2,a3), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverPos_LMA::sipChainIkSolverPos_LMA(const  ::ChainIkSolverPos_LMA& a0):  ::ChainIkSolverPos_LMA(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverPos_LMA::~sipChainIkSolverPos_LMA()
{
    sipInstanceDestroyed(sipPySelf);
}

void sipChainIkSolverPos_LMA::updateInternalDataStructures()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_updateInternalDataStructures);

    if (!sipMeth)
    {
         ::ChainIkSolverPos_LMA::updateInternalDataStructures();
        return;
    }

    extern void sipVH_PyKDL_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH_PyKDL_2(sipGILState, 0, sipPySelf, sipMeth);
}

int sipChainIkSolverPos_LMA::CartToJnt(const  ::JntArray& a0,const  ::Frame& a1, ::JntArray& a2)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,NULL,sipName_CartToJnt);

    if (!sipMeth)
        return  ::ChainIkSolverPos_LMA::CartToJnt(a0,a1,a2);

    extern int sipVH_PyKDL_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::JntArray&,const  ::Frame&, ::JntArray&);

    return sipVH_PyKDL_5(sipGILState, 0, sipPySelf, sipMeth, a0, a1, a2);
}


PyDoc_STRVAR(doc_ChainIkSolverPos_LMA_CartToJnt, "CartToJnt(self, q_init: JntArray, p_in: Frame, q_out: JntArray) -> int");

extern "C" {static PyObject *meth_ChainIkSolverPos_LMA_CartToJnt(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverPos_LMA_CartToJnt(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::JntArray* a0;
        const  ::Frame* a1;
         ::JntArray* a2;
         ::ChainIkSolverPos_LMA *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q_init,
            sipName_p_in,
            sipName_q_out,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9J9J9", &sipSelf, sipType_ChainIkSolverPos_LMA, &sipCpp, sipType_JntArray, &a0, sipType_Frame, &a1, sipType_JntArray, &a2))
        {
            int sipRes;

            sipRes = (sipSelfWasArg ? sipCpp-> ::ChainIkSolverPos_LMA::CartToJnt(*a0,*a1,*a2) : sipCpp->CartToJnt(*a0,*a1,*a2));

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverPos_LMA, sipName_CartToJnt, doc_ChainIkSolverPos_LMA_CartToJnt);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverPos_LMA_updateInternalDataStructures, "updateInternalDataStructures(self)");

extern "C" {static PyObject *meth_ChainIkSolverPos_LMA_updateInternalDataStructures(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverPos_LMA_updateInternalDataStructures(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::ChainIkSolverPos_LMA *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainIkSolverPos_LMA, &sipCpp))
        {
            (sipSelfWasArg ? sipCpp-> ::ChainIkSolverPos_LMA::updateInternalDataStructures() : sipCpp->updateInternalDataStructures());

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverPos_LMA, sipName_updateInternalDataStructures, doc_ChainIkSolverPos_LMA_updateInternalDataStructures);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_ChainIkSolverPos_LMA(void *, const sipTypeDef *);}
static void *cast_ChainIkSolverPos_LMA(void *sipCppV, const sipTypeDef *targetType)
{
     ::ChainIkSolverPos_LMA *sipCpp = reinterpret_cast< ::ChainIkSolverPos_LMA *>(sipCppV);

    if (targetType == sipType_ChainIkSolverPos)
        return static_cast< ::ChainIkSolverPos *>(sipCpp);

    if (targetType == sipType_SolverI)
        return static_cast< ::SolverI *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_ChainIkSolverPos_LMA(void *, int);}
static void release_ChainIkSolverPos_LMA(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipChainIkSolverPos_LMA *>(sipCppV);
    else
        delete reinterpret_cast< ::ChainIkSolverPos_LMA *>(sipCppV);
}


extern "C" {static void dealloc_ChainIkSolverPos_LMA(sipSimpleWrapper *);}
static void dealloc_ChainIkSolverPos_LMA(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipChainIkSolverPos_LMA *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_ChainIkSolverPos_LMA(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_ChainIkSolverPos_LMA(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_ChainIkSolverPos_LMA(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipChainIkSolverPos_LMA *sipCpp = 0;

    {
        const  ::Chain* a0;
        double a1 = 1e-05;
        int a2 = 500;
        double a3 = 1e-15;

        static const char *sipKwdList[] = {
            sipName_chain,
            sipName_eps,
            sipName__maxiter,
            sipName__eps_joints,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9|did", sipType_Chain, &a0, &a1, &a2, &a3))
        {
            sipCpp = new sipChainIkSolverPos_LMA(*a0,a1,a2,a3);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::ChainIkSolverPos_LMA* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_ChainIkSolverPos_LMA, &a0))
        {
            sipCpp = new sipChainIkSolverPos_LMA(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_ChainIkSolverPos_LMA[] = {{6, 255, 1}};


static PyMethodDef methods_ChainIkSolverPos_LMA[] = {
    {SIP_MLNAME_CAST(sipName_CartToJnt), (PyCFunction)meth_ChainIkSolverPos_LMA_CartToJnt, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainIkSolverPos_LMA_CartToJnt)},
    {SIP_MLNAME_CAST(sipName_updateInternalDataStructures), meth_ChainIkSolverPos_LMA_updateInternalDataStructures, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverPos_LMA_updateInternalDataStructures)}
};

PyDoc_STRVAR(doc_ChainIkSolverPos_LMA, "\1ChainIkSolverPos_LMA(chain: Chain, eps: float = 1e-05, _maxiter: int = 500, _eps_joints: float = 1e-15)\n"
"ChainIkSolverPos_LMA(ChainIkSolverPos_LMA)");


sipClassTypeDef sipTypeDef_PyKDL_ChainIkSolverPos_LMA = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_ChainIkSolverPos_LMA,
        {0},
        0
    },
    {
        sipNameNr_ChainIkSolverPos_LMA,
        {0, 0, 1},
        2, methods_ChainIkSolverPos_LMA,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_ChainIkSolverPos_LMA,
    -1,
    -1,
    supers_ChainIkSolverPos_LMA,
    0,
    init_type_ChainIkSolverPos_LMA,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_ChainIkSolverPos_LMA,
    0,
    0,
    0,
    release_ChainIkSolverPos_LMA,
    cast_ChainIkSolverPos_LMA,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 428 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainiksolvervel_wdls.hpp>
using namespace KDL;
#line 873 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"

#line 133 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 878 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"
#line 172 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 882 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"
#line 281 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 888 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"


class sipChainIkSolverVel_wdls : public  ::ChainIkSolverVel_wdls
{
public:
    sipChainIkSolverVel_wdls(const  ::Chain&,double,int);
    sipChainIkSolverVel_wdls(const  ::ChainIkSolverVel_wdls&);
    virtual ~sipChainIkSolverVel_wdls();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void updateInternalDataStructures();
    int CartToJnt(const  ::JntArray&,const  ::Twist&, ::JntArray&);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipChainIkSolverVel_wdls(const sipChainIkSolverVel_wdls &);
    sipChainIkSolverVel_wdls &operator = (const sipChainIkSolverVel_wdls &);

    char sipPyMethods[2];
};

sipChainIkSolverVel_wdls::sipChainIkSolverVel_wdls(const  ::Chain& a0,double a1,int a2):  ::ChainIkSolverVel_wdls(a0,a1,a2), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverVel_wdls::sipChainIkSolverVel_wdls(const  ::ChainIkSolverVel_wdls& a0):  ::ChainIkSolverVel_wdls(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverVel_wdls::~sipChainIkSolverVel_wdls()
{
    sipInstanceDestroyed(sipPySelf);
}

void sipChainIkSolverVel_wdls::updateInternalDataStructures()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_updateInternalDataStructures);

    if (!sipMeth)
    {
         ::ChainIkSolverVel_wdls::updateInternalDataStructures();
        return;
    }

    extern void sipVH_PyKDL_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH_PyKDL_2(sipGILState, 0, sipPySelf, sipMeth);
}

int sipChainIkSolverVel_wdls::CartToJnt(const  ::JntArray& a0,const  ::Twist& a1, ::JntArray& a2)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,NULL,sipName_CartToJnt);

    if (!sipMeth)
        return  ::ChainIkSolverVel_wdls::CartToJnt(a0,a1,a2);

    extern int sipVH_PyKDL_6(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::JntArray&,const  ::Twist&, ::JntArray&);

    return sipVH_PyKDL_6(sipGILState, 0, sipPySelf, sipMeth, a0, a1, a2);
}


PyDoc_STRVAR(doc_ChainIkSolverVel_wdls_CartToJnt, "CartToJnt(self, q_in: JntArray, v_in: Twist, qdot_out: JntArray) -> int");

extern "C" {static PyObject *meth_ChainIkSolverVel_wdls_CartToJnt(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_wdls_CartToJnt(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::JntArray* a0;
        const  ::Twist* a1;
         ::JntArray* a2;
         ::ChainIkSolverVel_wdls *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q_in,
            sipName_v_in,
            sipName_qdot_out,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9J9J9", &sipSelf, sipType_ChainIkSolverVel_wdls, &sipCpp, sipType_JntArray, &a0, sipType_Twist, &a1, sipType_JntArray, &a2))
        {
            int sipRes;

            sipRes = (sipSelfWasArg ? sipCpp-> ::ChainIkSolverVel_wdls::CartToJnt(*a0,*a1,*a2) : sipCpp->CartToJnt(*a0,*a1,*a2));

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_wdls, sipName_CartToJnt, doc_ChainIkSolverVel_wdls_CartToJnt);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_wdls_updateInternalDataStructures, "updateInternalDataStructures(self)");

extern "C" {static PyObject *meth_ChainIkSolverVel_wdls_updateInternalDataStructures(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_wdls_updateInternalDataStructures(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::ChainIkSolverVel_wdls *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainIkSolverVel_wdls, &sipCpp))
        {
            (sipSelfWasArg ? sipCpp-> ::ChainIkSolverVel_wdls::updateInternalDataStructures() : sipCpp->updateInternalDataStructures());

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_wdls, sipName_updateInternalDataStructures, doc_ChainIkSolverVel_wdls_updateInternalDataStructures);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_wdls_setWeightTS, "setWeightTS(self, List)");

extern "C" {static PyObject *meth_ChainIkSolverVel_wdls_setWeightTS(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_wdls_setWeightTS(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        PyObject * a0;
         ::ChainIkSolverVel_wdls *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BT", &sipSelf, sipType_ChainIkSolverVel_wdls, &sipCpp, &PyList_Type, &a0))
        {
            int sipIsErr = 0;

#line 439 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
    //void setWeightTS(const Eigen::MatrixXd& Mx);
    //Mx has to be a 6x6 Matrix

    Py_ssize_t numRows,numCols;
    double c_item;
    PyObject *list=a0;
    numRows=PyList_Size(list);
    PyObject *temp1;
    temp1=PyList_GetItem(list,0);
    numCols=PyList_Size(temp1);
    if (numRows!=numCols) {
       sipIsErr=1; //todo: raise exception
    }
    if (numRows!=6) {
       sipIsErr=1; //todo: raise exception
    }
    Eigen::MatrixXd Mx;
    Mx=Eigen::MatrixXd::Identity(numRows,numCols);
    
    for (Py_ssize_t r=0;r<numRows;r++) {
        PyObject *row;
        row=PyList_GetItem(list,r);
        if (numCols!=PyList_Size(row)) {
           sipIsErr=1; //todo: raise exception
        }
        for (Py_ssize_t c=0;c<numCols;c++) {
            PyObject *item;
            item=PyList_GetItem(row,c);
            c_item=PyFloat_AsDouble(item);
            Mx(r,c)= c_item;
        }
    }
    sipCpp->setWeightTS(Mx);
#line 1081 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"

            if (sipIsErr)
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_wdls, sipName_setWeightTS, doc_ChainIkSolverVel_wdls_setWeightTS);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_wdls_setWeightJS, "setWeightJS(self, List)");

extern "C" {static PyObject *meth_ChainIkSolverVel_wdls_setWeightJS(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_wdls_setWeightJS(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        PyObject * a0;
         ::ChainIkSolverVel_wdls *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BT", &sipSelf, sipType_ChainIkSolverVel_wdls, &sipCpp, &PyList_Type, &a0))
        {
            int sipIsErr = 0;

#line 476 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
    //void setWeightJS(const Eigen::MatrixXd& Mx);
    //Mx has to be a simetric positive definite Matrix
    //unsigned int nOfJoints=sipCpp->chain.getNrOfJoints(); //To check that we are receiving valid data dimensions. This doesn't work, chain is a private member. todo: How can we check for this?
    Py_ssize_t numRows,numCols;
    double c_item;
    PyObject *list=a0;
    numRows=PyList_Size(list);
    PyObject *temp1;
    temp1=PyList_GetItem(list,0);
    numCols=PyList_Size(temp1);
    if (numRows!=numCols) {
       sipIsErr=1; //todo: raise exception
    }
    Eigen::MatrixXd Mq;
    Mq=Eigen::MatrixXd::Identity(numRows,numCols);
    for (Py_ssize_t r=0;r<numRows;r++) {
        PyObject *row;
        row=PyList_GetItem(list,r);
        if (numCols!=PyList_Size(row)) {
           sipIsErr=1; //todo: raise exception
        }
        for (Py_ssize_t c=0;c<numCols;c++) {
            PyObject *item;
            item=PyList_GetItem(row,c);
            c_item=PyFloat_AsDouble(item);
            Mq(r,c)= c_item;
        }
    }
    sipCpp->setWeightJS(Mq);
#line 1144 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"

            if (sipIsErr)
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_wdls, sipName_setWeightJS, doc_ChainIkSolverVel_wdls_setWeightJS);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_wdls_setLambda, "setLambda(self, lambda_: float)");

extern "C" {static PyObject *meth_ChainIkSolverVel_wdls_setLambda(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_wdls_setLambda(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
         ::ChainIkSolverVel_wdls *sipCpp;

        static const char *sipKwdList[] = {
            sipName_lambda,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bd", &sipSelf, sipType_ChainIkSolverVel_wdls, &sipCpp, &a0))
        {
            sipCpp->setLambda(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_wdls, sipName_setLambda, doc_ChainIkSolverVel_wdls_setLambda);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_ChainIkSolverVel_wdls(void *, const sipTypeDef *);}
static void *cast_ChainIkSolverVel_wdls(void *sipCppV, const sipTypeDef *targetType)
{
     ::ChainIkSolverVel_wdls *sipCpp = reinterpret_cast< ::ChainIkSolverVel_wdls *>(sipCppV);

    if (targetType == sipType_ChainIkSolverVel)
        return static_cast< ::ChainIkSolverVel *>(sipCpp);

    if (targetType == sipType_SolverI)
        return static_cast< ::SolverI *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_ChainIkSolverVel_wdls(void *, int);}
static void release_ChainIkSolverVel_wdls(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipChainIkSolverVel_wdls *>(sipCppV);
    else
        delete reinterpret_cast< ::ChainIkSolverVel_wdls *>(sipCppV);
}


extern "C" {static void dealloc_ChainIkSolverVel_wdls(sipSimpleWrapper *);}
static void dealloc_ChainIkSolverVel_wdls(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipChainIkSolverVel_wdls *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_ChainIkSolverVel_wdls(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_ChainIkSolverVel_wdls(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_ChainIkSolverVel_wdls(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipChainIkSolverVel_wdls *sipCpp = 0;

    {
        const  ::Chain* a0;
        double a1 = 1e-05;
        int a2 = 150;

        static const char *sipKwdList[] = {
            sipName_chain,
            sipName_eps,
            sipName_maxiter,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9|di", sipType_Chain, &a0, &a1, &a2))
        {
            sipCpp = new sipChainIkSolverVel_wdls(*a0,a1,a2);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::ChainIkSolverVel_wdls* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_ChainIkSolverVel_wdls, &a0))
        {
            sipCpp = new sipChainIkSolverVel_wdls(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_ChainIkSolverVel_wdls[] = {{10, 255, 1}};


static PyMethodDef methods_ChainIkSolverVel_wdls[] = {
    {SIP_MLNAME_CAST(sipName_CartToJnt), (PyCFunction)meth_ChainIkSolverVel_wdls_CartToJnt, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_wdls_CartToJnt)},
    {SIP_MLNAME_CAST(sipName_setLambda), (PyCFunction)meth_ChainIkSolverVel_wdls_setLambda, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_wdls_setLambda)},
    {SIP_MLNAME_CAST(sipName_setWeightJS), meth_ChainIkSolverVel_wdls_setWeightJS, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_wdls_setWeightJS)},
    {SIP_MLNAME_CAST(sipName_setWeightTS), meth_ChainIkSolverVel_wdls_setWeightTS, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_wdls_setWeightTS)},
    {SIP_MLNAME_CAST(sipName_updateInternalDataStructures), meth_ChainIkSolverVel_wdls_updateInternalDataStructures, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_wdls_updateInternalDataStructures)}
};

PyDoc_STRVAR(doc_ChainIkSolverVel_wdls, "\1ChainIkSolverVel_wdls(chain: Chain, eps: float = 1e-05, maxiter: int = 150)\n"
"ChainIkSolverVel_wdls(ChainIkSolverVel_wdls)");


sipClassTypeDef sipTypeDef_PyKDL_ChainIkSolverVel_wdls = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_ChainIkSolverVel_wdls,
        {0},
        0
    },
    {
        sipNameNr_ChainIkSolverVel_wdls,
        {0, 0, 1},
        5, methods_ChainIkSolverVel_wdls,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_ChainIkSolverVel_wdls,
    -1,
    -1,
    supers_ChainIkSolverVel_wdls,
    0,
    init_type_ChainIkSolverVel_wdls,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_ChainIkSolverVel_wdls,
    0,
    0,
    0,
    release_ChainIkSolverVel_wdls,
    cast_ChainIkSolverVel_wdls,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 415 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainiksolvervel_pinv.hpp>
using namespace KDL;
#line 1346 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"

#line 133 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 1351 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"
#line 172 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 1355 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"
#line 281 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 1361 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"


class sipChainIkSolverVel_pinv : public  ::ChainIkSolverVel_pinv
{
public:
    sipChainIkSolverVel_pinv(const  ::Chain&,double,int);
    sipChainIkSolverVel_pinv(const  ::ChainIkSolverVel_pinv&);
    virtual ~sipChainIkSolverVel_pinv();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void updateInternalDataStructures();
    int CartToJnt(const  ::JntArray&,const  ::Twist&, ::JntArray&);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipChainIkSolverVel_pinv(const sipChainIkSolverVel_pinv &);
    sipChainIkSolverVel_pinv &operator = (const sipChainIkSolverVel_pinv &);

    char sipPyMethods[2];
};

sipChainIkSolverVel_pinv::sipChainIkSolverVel_pinv(const  ::Chain& a0,double a1,int a2):  ::ChainIkSolverVel_pinv(a0,a1,a2), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverVel_pinv::sipChainIkSolverVel_pinv(const  ::ChainIkSolverVel_pinv& a0):  ::ChainIkSolverVel_pinv(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverVel_pinv::~sipChainIkSolverVel_pinv()
{
    sipInstanceDestroyed(sipPySelf);
}

void sipChainIkSolverVel_pinv::updateInternalDataStructures()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_updateInternalDataStructures);

    if (!sipMeth)
    {
         ::ChainIkSolverVel_pinv::updateInternalDataStructures();
        return;
    }

    extern void sipVH_PyKDL_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH_PyKDL_2(sipGILState, 0, sipPySelf, sipMeth);
}

int sipChainIkSolverVel_pinv::CartToJnt(const  ::JntArray& a0,const  ::Twist& a1, ::JntArray& a2)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,NULL,sipName_CartToJnt);

    if (!sipMeth)
        return  ::ChainIkSolverVel_pinv::CartToJnt(a0,a1,a2);

    extern int sipVH_PyKDL_6(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::JntArray&,const  ::Twist&, ::JntArray&);

    return sipVH_PyKDL_6(sipGILState, 0, sipPySelf, sipMeth, a0, a1, a2);
}


PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_CartToJnt, "CartToJnt(self, q_in: JntArray, v_in: Twist, qdot_out: JntArray) -> int");

extern "C" {static PyObject *meth_ChainIkSolverVel_pinv_CartToJnt(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_pinv_CartToJnt(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::JntArray* a0;
        const  ::Twist* a1;
         ::JntArray* a2;
         ::ChainIkSolverVel_pinv *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q_in,
            sipName_v_in,
            sipName_qdot_out,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9J9J9", &sipSelf, sipType_ChainIkSolverVel_pinv, &sipCpp, sipType_JntArray, &a0, sipType_Twist, &a1, sipType_JntArray, &a2))
        {
            int sipRes;

            sipRes = (sipSelfWasArg ? sipCpp-> ::ChainIkSolverVel_pinv::CartToJnt(*a0,*a1,*a2) : sipCpp->CartToJnt(*a0,*a1,*a2));

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_pinv, sipName_CartToJnt, doc_ChainIkSolverVel_pinv_CartToJnt);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_updateInternalDataStructures, "updateInternalDataStructures(self)");

extern "C" {static PyObject *meth_ChainIkSolverVel_pinv_updateInternalDataStructures(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_pinv_updateInternalDataStructures(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::ChainIkSolverVel_pinv *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainIkSolverVel_pinv, &sipCpp))
        {
            (sipSelfWasArg ? sipCpp-> ::ChainIkSolverVel_pinv::updateInternalDataStructures() : sipCpp->updateInternalDataStructures());

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_pinv, sipName_updateInternalDataStructures, doc_ChainIkSolverVel_pinv_updateInternalDataStructures);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_ChainIkSolverVel_pinv(void *, const sipTypeDef *);}
static void *cast_ChainIkSolverVel_pinv(void *sipCppV, const sipTypeDef *targetType)
{
     ::ChainIkSolverVel_pinv *sipCpp = reinterpret_cast< ::ChainIkSolverVel_pinv *>(sipCppV);

    if (targetType == sipType_ChainIkSolverVel)
        return static_cast< ::ChainIkSolverVel *>(sipCpp);

    if (targetType == sipType_SolverI)
        return static_cast< ::SolverI *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_ChainIkSolverVel_pinv(void *, int);}
static void release_ChainIkSolverVel_pinv(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipChainIkSolverVel_pinv *>(sipCppV);
    else
        delete reinterpret_cast< ::ChainIkSolverVel_pinv *>(sipCppV);
}


extern "C" {static void dealloc_ChainIkSolverVel_pinv(sipSimpleWrapper *);}
static void dealloc_ChainIkSolverVel_pinv(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipChainIkSolverVel_pinv *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_ChainIkSolverVel_pinv(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_ChainIkSolverVel_pinv(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_ChainIkSolverVel_pinv(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipChainIkSolverVel_pinv *sipCpp = 0;

    {
        const  ::Chain* a0;
        double a1 = 1e-05;
        int a2 = 150;

        static const char *sipKwdList[] = {
            sipName_chain,
            sipName_eps,
            sipName_maxiter,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9|di", sipType_Chain, &a0, &a1, &a2))
        {
            sipCpp = new sipChainIkSolverVel_pinv(*a0,a1,a2);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::ChainIkSolverVel_pinv* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_ChainIkSolverVel_pinv, &a0))
        {
            sipCpp = new sipChainIkSolverVel_pinv(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_ChainIkSolverVel_pinv[] = {{10, 255, 1}};


static PyMethodDef methods_ChainIkSolverVel_pinv[] = {
    {SIP_MLNAME_CAST(sipName_CartToJnt), (PyCFunction)meth_ChainIkSolverVel_pinv_CartToJnt, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_pinv_CartToJnt)},
    {SIP_MLNAME_CAST(sipName_updateInternalDataStructures), meth_ChainIkSolverVel_pinv_updateInternalDataStructures, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_pinv_updateInternalDataStructures)}
};

PyDoc_STRVAR(doc_ChainIkSolverVel_pinv, "\1ChainIkSolverVel_pinv(chain: Chain, eps: float = 1e-05, maxiter: int = 150)\n"
"ChainIkSolverVel_pinv(ChainIkSolverVel_pinv)");


sipClassTypeDef sipTypeDef_PyKDL_ChainIkSolverVel_pinv = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_ChainIkSolverVel_pinv,
        {0},
        0
    },
    {
        sipNameNr_ChainIkSolverVel_pinv,
        {0, 0, 1},
        2, methods_ChainIkSolverVel_pinv,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_ChainIkSolverVel_pinv,
    -1,
    -1,
    supers_ChainIkSolverVel_pinv,
    0,
    init_type_ChainIkSolverVel_pinv,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_ChainIkSolverVel_pinv,
    0,
    0,
    0,
    release_ChainIkSolverVel_pinv,
    cast_ChainIkSolverVel_pinv,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 400 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainiksolverpos_nr_jl.hpp>
using namespace KDL;
#line 1654 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"

#line 133 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 1659 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"
#line 172 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 1663 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"
#line 320 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainfksolver.hpp>
using namespace KDL;
#line 1667 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"
#line 374 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainiksolver.hpp>
using namespace KDL;
#line 1671 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"
#line 201 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 1677 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"


class sipChainIkSolverPos_NR_JL : public  ::ChainIkSolverPos_NR_JL
{
public:
    sipChainIkSolverPos_NR_JL(const  ::Chain&,const  ::JntArray&,const  ::JntArray&, ::ChainFkSolverPos&, ::ChainIkSolverVel&,uint,double);
    sipChainIkSolverPos_NR_JL(const  ::ChainIkSolverPos_NR_JL&);
    virtual ~sipChainIkSolverPos_NR_JL();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void updateInternalDataStructures();
    int CartToJnt(const  ::JntArray&,const  ::Frame&, ::JntArray&);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipChainIkSolverPos_NR_JL(const sipChainIkSolverPos_NR_JL &);
    sipChainIkSolverPos_NR_JL &operator = (const sipChainIkSolverPos_NR_JL &);

    char sipPyMethods[2];
};

sipChainIkSolverPos_NR_JL::sipChainIkSolverPos_NR_JL(const  ::Chain& a0,const  ::JntArray& a1,const  ::JntArray& a2, ::ChainFkSolverPos& a3, ::ChainIkSolverVel& a4,uint a5,double a6):  ::ChainIkSolverPos_NR_JL(a0,a1,a2,a3,a4,a5,a6), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverPos_NR_JL::sipChainIkSolverPos_NR_JL(const  ::ChainIkSolverPos_NR_JL& a0):  ::ChainIkSolverPos_NR_JL(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverPos_NR_JL::~sipChainIkSolverPos_NR_JL()
{
    sipInstanceDestroyed(sipPySelf);
}

void sipChainIkSolverPos_NR_JL::updateInternalDataStructures()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_updateInternalDataStructures);

    if (!sipMeth)
    {
         ::ChainIkSolverPos_NR_JL::updateInternalDataStructures();
        return;
    }

    extern void sipVH_PyKDL_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH_PyKDL_2(sipGILState, 0, sipPySelf, sipMeth);
}

int sipChainIkSolverPos_NR_JL::CartToJnt(const  ::JntArray& a0,const  ::Frame& a1, ::JntArray& a2)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,NULL,sipName_CartToJnt);

    if (!sipMeth)
        return  ::ChainIkSolverPos_NR_JL::CartToJnt(a0,a1,a2);

    extern int sipVH_PyKDL_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::JntArray&,const  ::Frame&, ::JntArray&);

    return sipVH_PyKDL_5(sipGILState, 0, sipPySelf, sipMeth, a0, a1, a2);
}


PyDoc_STRVAR(doc_ChainIkSolverPos_NR_JL_CartToJnt, "CartToJnt(self, q_init: JntArray, p_in: Frame, q_out: JntArray) -> int");

extern "C" {static PyObject *meth_ChainIkSolverPos_NR_JL_CartToJnt(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverPos_NR_JL_CartToJnt(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::JntArray* a0;
        const  ::Frame* a1;
         ::JntArray* a2;
         ::ChainIkSolverPos_NR_JL *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q_init,
            sipName_p_in,
            sipName_q_out,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9J9J9", &sipSelf, sipType_ChainIkSolverPos_NR_JL, &sipCpp, sipType_JntArray, &a0, sipType_Frame, &a1, sipType_JntArray, &a2))
        {
            int sipRes;

            sipRes = (sipSelfWasArg ? sipCpp-> ::ChainIkSolverPos_NR_JL::CartToJnt(*a0,*a1,*a2) : sipCpp->CartToJnt(*a0,*a1,*a2));

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverPos_NR_JL, sipName_CartToJnt, doc_ChainIkSolverPos_NR_JL_CartToJnt);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverPos_NR_JL_updateInternalDataStructures, "updateInternalDataStructures(self)");

extern "C" {static PyObject *meth_ChainIkSolverPos_NR_JL_updateInternalDataStructures(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverPos_NR_JL_updateInternalDataStructures(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::ChainIkSolverPos_NR_JL *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainIkSolverPos_NR_JL, &sipCpp))
        {
            (sipSelfWasArg ? sipCpp-> ::ChainIkSolverPos_NR_JL::updateInternalDataStructures() : sipCpp->updateInternalDataStructures());

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverPos_NR_JL, sipName_updateInternalDataStructures, doc_ChainIkSolverPos_NR_JL_updateInternalDataStructures);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_ChainIkSolverPos_NR_JL(void *, const sipTypeDef *);}
static void *cast_ChainIkSolverPos_NR_JL(void *sipCppV, const sipTypeDef *targetType)
{
     ::ChainIkSolverPos_NR_JL *sipCpp = reinterpret_cast< ::ChainIkSolverPos_NR_JL *>(sipCppV);

    if (targetType == sipType_ChainIkSolverPos)
        return static_cast< ::ChainIkSolverPos *>(sipCpp);

    if (targetType == sipType_SolverI)
        return static_cast< ::SolverI *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_ChainIkSolverPos_NR_JL(void *, int);}
static void release_ChainIkSolverPos_NR_JL(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipChainIkSolverPos_NR_JL *>(sipCppV);
    else
        delete reinterpret_cast< ::ChainIkSolverPos_NR_JL *>(sipCppV);
}


extern "C" {static void dealloc_ChainIkSolverPos_NR_JL(sipSimpleWrapper *);}
static void dealloc_ChainIkSolverPos_NR_JL(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipChainIkSolverPos_NR_JL *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_ChainIkSolverPos_NR_JL(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_ChainIkSolverPos_NR_JL(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_ChainIkSolverPos_NR_JL(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipChainIkSolverPos_NR_JL *sipCpp = 0;

    {
        const  ::Chain* a0;
        const  ::JntArray* a1;
        const  ::JntArray* a2;
         ::ChainFkSolverPos* a3;
         ::ChainIkSolverVel* a4;
        uint a5 = 100;
        double a6 = epsilon;

        static const char *sipKwdList[] = {
            sipName_chain,
            sipName_q_min,
            sipName_q_max,
            sipName_fksolver,
            sipName_iksolver,
            sipName_maxiter,
            sipName_eps,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9J9J9J9J9|ud", sipType_Chain, &a0, sipType_JntArray, &a1, sipType_JntArray, &a2, sipType_ChainFkSolverPos, &a3, sipType_ChainIkSolverVel, &a4, &a5, &a6))
        {
            sipCpp = new sipChainIkSolverPos_NR_JL(*a0,*a1,*a2,*a3,*a4,a5,a6);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::ChainIkSolverPos_NR_JL* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_ChainIkSolverPos_NR_JL, &a0))
        {
            sipCpp = new sipChainIkSolverPos_NR_JL(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_ChainIkSolverPos_NR_JL[] = {{6, 255, 1}};


static PyMethodDef methods_ChainIkSolverPos_NR_JL[] = {
    {SIP_MLNAME_CAST(sipName_CartToJnt), (PyCFunction)meth_ChainIkSolverPos_NR_JL_CartToJnt, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainIkSolverPos_NR_JL_CartToJnt)},
    {SIP_MLNAME_CAST(sipName_updateInternalDataStructures), meth_ChainIkSolverPos_NR_JL_updateInternalDataStructures, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverPos_NR_JL_updateInternalDataStructures)}
};

PyDoc_STRVAR(doc_ChainIkSolverPos_NR_JL, "\1ChainIkSolverPos_NR_JL(chain: Chain, q_min: JntArray, q_max: JntArray, fksolver: ChainFkSolverPos, iksolver: ChainIkSolverVel, maxiter: int = 100, eps: float = epsilon)\n"
"ChainIkSolverPos_NR_JL(ChainIkSolverPos_NR_JL)");


sipClassTypeDef sipTypeDef_PyKDL_ChainIkSolverPos_NR_JL = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_ChainIkSolverPos_NR_JL,
        {0},
        0
    },
    {
        sipNameNr_ChainIkSolverPos_NR_JL,
        {0, 0, 1},
        2, methods_ChainIkSolverPos_NR_JL,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_ChainIkSolverPos_NR_JL,
    -1,
    -1,
    supers_ChainIkSolverPos_NR_JL,
    0,
    init_type_ChainIkSolverPos_NR_JL,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_ChainIkSolverPos_NR_JL,
    0,
    0,
    0,
    release_ChainIkSolverPos_NR_JL,
    cast_ChainIkSolverPos_NR_JL,
    0,
    0,
    0,
    0,
    0,
    0
};
