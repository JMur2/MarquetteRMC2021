/*
 * Module code.
 *
 * Generated by SIP 4.19.7
 */

#include "sipAPIPyKDL.h"

#line 172 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 13 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"

#line 21 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/std_string.sip"
#include <string>
#line 17 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"


PyDoc_STRVAR(doc_JntArray_rows, "rows(self) -> int");

extern "C" {static PyObject *meth_JntArray_rows(PyObject *, PyObject *);}
static PyObject *meth_JntArray_rows(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::JntArray *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_JntArray, &sipCpp))
        {
            uint sipRes;

            sipRes = sipCpp->rows();

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_JntArray, sipName_rows, doc_JntArray_rows);

    return NULL;
}


PyDoc_STRVAR(doc_JntArray_columns, "columns(self) -> int");

extern "C" {static PyObject *meth_JntArray_columns(PyObject *, PyObject *);}
static PyObject *meth_JntArray_columns(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::JntArray *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_JntArray, &sipCpp))
        {
            uint sipRes;

            sipRes = sipCpp->columns();

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_JntArray, sipName_columns, doc_JntArray_columns);

    return NULL;
}


PyDoc_STRVAR(doc_JntArray_resize, "resize(self, newSize: int)");

extern "C" {static PyObject *meth_JntArray_resize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_JntArray_resize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        uint a0;
         ::JntArray *sipCpp;

        static const char *sipKwdList[] = {
            sipName_newSize,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bu", &sipSelf, sipType_JntArray, &sipCpp, &a0))
        {
            sipCpp->resize(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_JntArray, sipName_resize, doc_JntArray_resize);

    return NULL;
}


extern "C" {static PyObject *slot_JntArray___ne__(PyObject *,PyObject *);}
static PyObject *slot_JntArray___ne__(PyObject *sipSelf,PyObject *sipArg)
{
     ::JntArray *sipCpp = reinterpret_cast< ::JntArray *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_JntArray));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        const  ::JntArray* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_JntArray, &a0))
        {
            bool sipRes;

            sipRes = !operator==((*sipCpp), *a0);

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, ne_slot, sipType_JntArray, sipSelf, sipArg);
}


extern "C" {static PyObject *slot_JntArray___eq__(PyObject *,PyObject *);}
static PyObject *slot_JntArray___eq__(PyObject *sipSelf,PyObject *sipArg)
{
     ::JntArray *sipCpp = reinterpret_cast< ::JntArray *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_JntArray));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        const  ::JntArray* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_JntArray, &a0))
        {
            bool sipRes;

            sipRes = operator==((*sipCpp), *a0);

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, eq_slot, sipType_JntArray, sipSelf, sipArg);
}


extern "C" {static PyObject *slot_JntArray___repr__(PyObject *);}
static PyObject *slot_JntArray___repr__(PyObject *sipSelf)
{
     ::JntArray *sipCpp = reinterpret_cast< ::JntArray *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_JntArray));

    if (!sipCpp)
        return 0;


    {
        {
            const  ::std::string*sipRes = 0;

#line 203 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
    std::stringstream ss;
    ss<<sipCpp->data;
    std::string s(ss.str());
    sipRes=&s;
#line 190 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"

            return sipConvertFromType(const_cast< ::std::string *>(sipRes),sipType_std_string,NULL);
        }
    }

    return 0;
}


extern "C" {static int slot_JntArray___setitem__(PyObject *,PyObject *);}
static int slot_JntArray___setitem__(PyObject *sipSelf,PyObject *sipArgs)
{
     ::JntArray *sipCpp = reinterpret_cast< ::JntArray *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_JntArray));

    if (!sipCpp)
        return -1;

    PyObject *sipParseErr = NULL;

    {
        int a0;
        double a1;

        if (sipParseArgs(&sipParseErr, sipArgs, "id", &a0, &a1))
        {
#line 194 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
    if (a0 < 0 || a0 >= (int)sipCpp->rows()) {
        PyErr_SetString(PyExc_IndexError, "JntArray index out of range");
        return 0;
    }
    (*sipCpp)(a0)=a1;
#line 222 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"

            return 0;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_JntArray, sipName___setitem__, NULL);

    return -1;
}


extern "C" {static PyObject *slot_JntArray___getitem__(PyObject *,PyObject *);}
static PyObject *slot_JntArray___getitem__(PyObject *sipSelf,PyObject *sipArg)
{
     ::JntArray *sipCpp = reinterpret_cast< ::JntArray *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_JntArray));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        int a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1i", &a0))
        {
            double sipRes = 0;

#line 185 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
    if (a0 < 0 || a0 >= (int)sipCpp->rows()) {
        PyErr_SetString(PyExc_IndexError, "JntArray index out of range");
        return 0;
    }
    sipRes=(*sipCpp)(a0);
#line 258 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_JntArray, sipName___getitem__, NULL);

    return 0;
}


/* Call the instance's destructor. */
extern "C" {static void release_JntArray(void *, int);}
static void release_JntArray(void *sipCppV, int)
{
    delete reinterpret_cast< ::JntArray *>(sipCppV);
}


extern "C" {static void dealloc_JntArray(sipSimpleWrapper *);}
static void dealloc_JntArray(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_JntArray(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_JntArray(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_JntArray(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::JntArray *sipCpp = 0;

    {
        uint a0;

        static const char *sipKwdList[] = {
            sipName_size,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "u", &a0))
        {
            sipCpp = new  ::JntArray(a0);

            return sipCpp;
        }
    }

    {
        const  ::JntArray* a0;

        static const char *sipKwdList[] = {
            sipName_arg,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9", sipType_JntArray, &a0))
        {
            sipCpp = new  ::JntArray(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's Python slots. */
static sipPySlotDef slots_JntArray[] = {
    {(void *)slot_JntArray___ne__, ne_slot},
    {(void *)slot_JntArray___eq__, eq_slot},
    {(void *)slot_JntArray___repr__, repr_slot},
    {(void *)slot_JntArray___setitem__, setitem_slot},
    {(void *)slot_JntArray___getitem__, getitem_slot},
    {0, (sipPySlotType)0}
};


static PyMethodDef methods_JntArray[] = {
    {SIP_MLNAME_CAST(sipName_columns), meth_JntArray_columns, METH_VARARGS, SIP_MLDOC_CAST(doc_JntArray_columns)},
    {SIP_MLNAME_CAST(sipName_resize), (PyCFunction)meth_JntArray_resize, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_JntArray_resize)},
    {SIP_MLNAME_CAST(sipName_rows), meth_JntArray_rows, METH_VARARGS, SIP_MLDOC_CAST(doc_JntArray_rows)}
};

PyDoc_STRVAR(doc_JntArray, "\1JntArray(size: int)\n"
"JntArray(arg: JntArray)");


sipClassTypeDef sipTypeDef_PyKDL_JntArray = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_JntArray,
        {0},
        0
    },
    {
        sipNameNr_JntArray,
        {0, 0, 1},
        3, methods_JntArray,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_JntArray,
    -1,
    -1,
    0,
    slots_JntArray,
    init_type_JntArray,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_JntArray,
    0,
    0,
    0,
    release_JntArray,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 153 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/tree.hpp>
using namespace KDL;
#line 403 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"

#line 21 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/std_string.sip"
#include <string>
#line 407 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"
#line 133 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 411 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"
#line 103 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/segment.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 416 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"


PyDoc_STRVAR(doc_Tree_addSegment, "addSegment(self, segment: Segment, hook_name: object) -> bool");

extern "C" {static PyObject *meth_Tree_addSegment(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Tree_addSegment(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Segment* a0;
        const  ::std::string* a1;
        int a1State = 0;
         ::Tree *sipCpp;

        static const char *sipKwdList[] = {
            sipName_segment,
            sipName_hook_name,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9J1", &sipSelf, sipType_Tree, &sipCpp, sipType_Segment, &a0, sipType_std_string,&a1, &a1State))
        {
            bool sipRes;

            sipRes = sipCpp->addSegment(*a0,*a1);
            sipReleaseType(const_cast< ::std::string *>(a1),sipType_std_string,a1State);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Tree, sipName_addSegment, doc_Tree_addSegment);

    return NULL;
}


PyDoc_STRVAR(doc_Tree_getNrOfJoints, "getNrOfJoints(self) -> int");

extern "C" {static PyObject *meth_Tree_getNrOfJoints(PyObject *, PyObject *);}
static PyObject *meth_Tree_getNrOfJoints(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Tree *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Tree, &sipCpp))
        {
            uint sipRes;

            sipRes = sipCpp->getNrOfJoints();

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Tree, sipName_getNrOfJoints, doc_Tree_getNrOfJoints);

    return NULL;
}


PyDoc_STRVAR(doc_Tree_getNrOfSegments, "getNrOfSegments(self) -> int");

extern "C" {static PyObject *meth_Tree_getNrOfSegments(PyObject *, PyObject *);}
static PyObject *meth_Tree_getNrOfSegments(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Tree *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Tree, &sipCpp))
        {
            uint sipRes;

            sipRes = sipCpp->getNrOfSegments();

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Tree, sipName_getNrOfSegments, doc_Tree_getNrOfSegments);

    return NULL;
}


PyDoc_STRVAR(doc_Tree_getChain, "getChain(self, chain_root: object, chain_tip: object) -> Chain");

extern "C" {static PyObject *meth_Tree_getChain(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Tree_getChain(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::std::string* a0;
        int a0State = 0;
        const  ::std::string* a1;
        int a1State = 0;
        const  ::Tree *sipCpp;

        static const char *sipKwdList[] = {
            sipName_chain_root,
            sipName_chain_tip,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1J1", &sipSelf, sipType_Tree, &sipCpp, sipType_std_string,&a0, &a0State, sipType_std_string,&a1, &a1State))
        {
             ::Chain*sipRes = 0;

#line 163 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
    Chain* chain = new Chain();
    sipCpp->getChain(*a0, *a1, *chain);
    sipRes = chain;
#line 540 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"
            sipReleaseType(const_cast< ::std::string *>(a0),sipType_std_string,a0State);
            sipReleaseType(const_cast< ::std::string *>(a1),sipType_std_string,a1State);

            return sipConvertFromType(sipRes,sipType_Chain,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Tree, sipName_getChain, doc_Tree_getChain);

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_Tree(void *, int);}
static void release_Tree(void *sipCppV, int)
{
    delete reinterpret_cast< ::Tree *>(sipCppV);
}


extern "C" {static void assign_Tree(void *, SIP_SSIZE_T, void *);}
static void assign_Tree(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::Tree *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::Tree *>(sipSrc);
}


extern "C" {static void *array_Tree(SIP_SSIZE_T);}
static void *array_Tree(SIP_SSIZE_T sipNrElem)
{
    return new  ::Tree[sipNrElem];
}


extern "C" {static void *copy_Tree(const void *, SIP_SSIZE_T);}
static void *copy_Tree(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::Tree(reinterpret_cast<const  ::Tree *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_Tree(sipSimpleWrapper *);}
static void dealloc_Tree(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_Tree(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_Tree(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_Tree(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::Tree *sipCpp = 0;

    {
        const  ::std::string& a0def = "root";
        const  ::std::string* a0 = &a0def;
        int a0State = 0;

        static const char *sipKwdList[] = {
            sipName_root_name,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|J1", sipType_std_string,&a0, &a0State))
        {
            sipCpp = new  ::Tree(*a0);
            sipReleaseType(const_cast< ::std::string *>(a0),sipType_std_string,a0State);

            return sipCpp;
        }
    }

    {
        const  ::Tree* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_Tree, &a0))
        {
            sipCpp = new  ::Tree(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


static PyMethodDef methods_Tree[] = {
    {SIP_MLNAME_CAST(sipName_addSegment), (PyCFunction)meth_Tree_addSegment, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Tree_addSegment)},
    {SIP_MLNAME_CAST(sipName_getChain), (PyCFunction)meth_Tree_getChain, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Tree_getChain)},
    {SIP_MLNAME_CAST(sipName_getNrOfJoints), meth_Tree_getNrOfJoints, METH_VARARGS, SIP_MLDOC_CAST(doc_Tree_getNrOfJoints)},
    {SIP_MLNAME_CAST(sipName_getNrOfSegments), meth_Tree_getNrOfSegments, METH_VARARGS, SIP_MLDOC_CAST(doc_Tree_getNrOfSegments)}
};

PyDoc_STRVAR(doc_Tree, "\1Tree(root_name: object = \"root\")\n"
"Tree(Tree)");


sipClassTypeDef sipTypeDef_PyKDL_Tree = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_Tree,
        {0},
        0
    },
    {
        sipNameNr_Tree,
        {0, 0, 1},
        4, methods_Tree,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_Tree,
    -1,
    -1,
    0,
    0,
    init_type_Tree,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_Tree,
    assign_Tree,
    array_Tree,
    copy_Tree,
    release_Tree,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 133 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 697 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"

#line 103 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/segment.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 703 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"


PyDoc_STRVAR(doc_Chain_addSegment, "addSegment(self, segment: Segment)");

extern "C" {static PyObject *meth_Chain_addSegment(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Chain_addSegment(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Segment* a0;
         ::Chain *sipCpp;

        static const char *sipKwdList[] = {
            sipName_segment,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_Chain, &sipCpp, sipType_Segment, &a0))
        {
            sipCpp->addSegment(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Chain, sipName_addSegment, doc_Chain_addSegment);

    return NULL;
}


PyDoc_STRVAR(doc_Chain_addChain, "addChain(self, chain: Chain)");

extern "C" {static PyObject *meth_Chain_addChain(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Chain_addChain(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Chain* a0;
         ::Chain *sipCpp;

        static const char *sipKwdList[] = {
            sipName_chain,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_Chain, &sipCpp, sipType_Chain, &a0))
        {
            sipCpp->addChain(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Chain, sipName_addChain, doc_Chain_addChain);

    return NULL;
}


PyDoc_STRVAR(doc_Chain_getNrOfJoints, "getNrOfJoints(self) -> int");

extern "C" {static PyObject *meth_Chain_getNrOfJoints(PyObject *, PyObject *);}
static PyObject *meth_Chain_getNrOfJoints(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Chain *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Chain, &sipCpp))
        {
            uint sipRes;

            sipRes = sipCpp->getNrOfJoints();

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Chain, sipName_getNrOfJoints, doc_Chain_getNrOfJoints);

    return NULL;
}


PyDoc_STRVAR(doc_Chain_getNrOfSegments, "getNrOfSegments(self) -> int");

extern "C" {static PyObject *meth_Chain_getNrOfSegments(PyObject *, PyObject *);}
static PyObject *meth_Chain_getNrOfSegments(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Chain *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Chain, &sipCpp))
        {
            uint sipRes;

            sipRes = sipCpp->getNrOfSegments();

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Chain, sipName_getNrOfSegments, doc_Chain_getNrOfSegments);

    return NULL;
}


PyDoc_STRVAR(doc_Chain_getSegment, "getSegment(self, nr: int) -> Segment");

extern "C" {static PyObject *meth_Chain_getSegment(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Chain_getSegment(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        uint a0;
        const  ::Chain *sipCpp;

        static const char *sipKwdList[] = {
            sipName_nr,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bu", &sipSelf, sipType_Chain, &sipCpp, &a0))
        {
             ::Segment*sipRes;

            sipRes = new  ::Segment(sipCpp->getSegment(a0));

            return sipConvertFromNewType(sipRes,sipType_Segment,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Chain, sipName_getSegment, doc_Chain_getSegment);

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_Chain(void *, int);}
static void release_Chain(void *sipCppV, int)
{
    delete reinterpret_cast< ::Chain *>(sipCppV);
}


extern "C" {static void assign_Chain(void *, SIP_SSIZE_T, void *);}
static void assign_Chain(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::Chain *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::Chain *>(sipSrc);
}


extern "C" {static void *array_Chain(SIP_SSIZE_T);}
static void *array_Chain(SIP_SSIZE_T sipNrElem)
{
    return new  ::Chain[sipNrElem];
}


extern "C" {static void *copy_Chain(const void *, SIP_SSIZE_T);}
static void *copy_Chain(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::Chain(reinterpret_cast<const  ::Chain *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_Chain(sipSimpleWrapper *);}
static void dealloc_Chain(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_Chain(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_Chain(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_Chain(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::Chain *sipCpp = 0;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            sipCpp = new  ::Chain();

            return sipCpp;
        }
    }

    {
        const  ::Chain* a0;

        static const char *sipKwdList[] = {
            sipName_in,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9", sipType_Chain, &a0))
        {
            sipCpp = new  ::Chain(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


static PyMethodDef methods_Chain[] = {
    {SIP_MLNAME_CAST(sipName_addChain), (PyCFunction)meth_Chain_addChain, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Chain_addChain)},
    {SIP_MLNAME_CAST(sipName_addSegment), (PyCFunction)meth_Chain_addSegment, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Chain_addSegment)},
    {SIP_MLNAME_CAST(sipName_getNrOfJoints), meth_Chain_getNrOfJoints, METH_VARARGS, SIP_MLDOC_CAST(doc_Chain_getNrOfJoints)},
    {SIP_MLNAME_CAST(sipName_getNrOfSegments), meth_Chain_getNrOfSegments, METH_VARARGS, SIP_MLDOC_CAST(doc_Chain_getNrOfSegments)},
    {SIP_MLNAME_CAST(sipName_getSegment), (PyCFunction)meth_Chain_getSegment, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Chain_getSegment)}
};

PyDoc_STRVAR(doc_Chain, "\1Chain()\n"
"Chain(in_: Chain)");


sipClassTypeDef sipTypeDef_PyKDL_Chain = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_Chain,
        {0},
        0
    },
    {
        sipNameNr_Chain,
        {0, 0, 1},
        5, methods_Chain,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_Chain,
    -1,
    -1,
    0,
    0,
    init_type_Chain,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_Chain,
    assign_Chain,
    array_Chain,
    copy_Chain,
    release_Chain,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 103 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/segment.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 998 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"

#line 21 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/std_string.sip"
#include <string>
#line 1002 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"
#line 25 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/joint.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 1007 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"
#line 201 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 1013 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"
#line 81 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/rigidbodyinertia.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 1018 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"
#line 281 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 1024 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"


PyDoc_STRVAR(doc_Segment_getFrameToTip, "getFrameToTip(self) -> Frame");

extern "C" {static PyObject *meth_Segment_getFrameToTip(PyObject *, PyObject *);}
static PyObject *meth_Segment_getFrameToTip(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Segment *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Segment, &sipCpp))
        {
             ::Frame*sipRes;

            sipRes = new  ::Frame(sipCpp->getFrameToTip());

            return sipConvertFromNewType(sipRes,sipType_Frame,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Segment, sipName_getFrameToTip, doc_Segment_getFrameToTip);

    return NULL;
}


PyDoc_STRVAR(doc_Segment_pose, "pose(self, q: float) -> Frame");

extern "C" {static PyObject *meth_Segment_pose(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Segment_pose(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
        const  ::Segment *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bd", &sipSelf, sipType_Segment, &sipCpp, &a0))
        {
             ::Frame*sipRes;

            sipRes = new  ::Frame(sipCpp->pose(a0));

            return sipConvertFromNewType(sipRes,sipType_Frame,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Segment, sipName_pose, doc_Segment_pose);

    return NULL;
}


PyDoc_STRVAR(doc_Segment_twist, "twist(self, q: float, qdot: float) -> Twist");

extern "C" {static PyObject *meth_Segment_twist(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Segment_twist(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
        double a1;
        const  ::Segment *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q,
            sipName_qdot,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bdd", &sipSelf, sipType_Segment, &sipCpp, &a0, &a1))
        {
             ::Twist*sipRes;

            sipRes = new  ::Twist(sipCpp->twist(a0,a1));

            return sipConvertFromNewType(sipRes,sipType_Twist,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Segment, sipName_twist, doc_Segment_twist);

    return NULL;
}


PyDoc_STRVAR(doc_Segment_getName, "getName(self) -> object");

extern "C" {static PyObject *meth_Segment_getName(PyObject *, PyObject *);}
static PyObject *meth_Segment_getName(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Segment *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Segment, &sipCpp))
        {
             ::std::string*sipRes;

            sipRes = new  ::std::string(sipCpp->getName());

            return sipConvertFromNewType(sipRes,sipType_std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Segment, sipName_getName, doc_Segment_getName);

    return NULL;
}


PyDoc_STRVAR(doc_Segment_getJoint, "getJoint(self) -> Joint");

extern "C" {static PyObject *meth_Segment_getJoint(PyObject *, PyObject *);}
static PyObject *meth_Segment_getJoint(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Segment *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Segment, &sipCpp))
        {
             ::Joint*sipRes;

            sipRes = new  ::Joint(sipCpp->getJoint());

            return sipConvertFromNewType(sipRes,sipType_Joint,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Segment, sipName_getJoint, doc_Segment_getJoint);

    return NULL;
}


PyDoc_STRVAR(doc_Segment_getInertia, "getInertia(self) -> RigidBodyInertia");

extern "C" {static PyObject *meth_Segment_getInertia(PyObject *, PyObject *);}
static PyObject *meth_Segment_getInertia(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Segment *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Segment, &sipCpp))
        {
             ::RigidBodyInertia*sipRes;

            sipRes = new  ::RigidBodyInertia(sipCpp->getInertia());

            return sipConvertFromNewType(sipRes,sipType_RigidBodyInertia,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Segment, sipName_getInertia, doc_Segment_getInertia);

    return NULL;
}


PyDoc_STRVAR(doc_Segment_setInertia, "setInertia(self, Iin: RigidBodyInertia)");

extern "C" {static PyObject *meth_Segment_setInertia(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Segment_setInertia(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::RigidBodyInertia* a0;
         ::Segment *sipCpp;

        static const char *sipKwdList[] = {
            sipName_Iin,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_Segment, &sipCpp, sipType_RigidBodyInertia, &a0))
        {
            sipCpp->setInertia(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Segment, sipName_setInertia, doc_Segment_setInertia);

    return NULL;
}


extern "C" {static PyObject *slot_Segment___repr__(PyObject *);}
static PyObject *slot_Segment___repr__(PyObject *sipSelf)
{
     ::Segment *sipCpp = reinterpret_cast< ::Segment *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_Segment));

    if (!sipCpp)
        return 0;


    {
        {
            const  ::std::string*sipRes = 0;

#line 114 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
    std::stringstream ss;
    ss<<(*sipCpp);
    std::string s(ss.str());
    sipRes=&s;
#line 1257 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"

            return sipConvertFromType(const_cast< ::std::string *>(sipRes),sipType_std_string,NULL);
        }
    }

    return 0;
}


/* Call the instance's destructor. */
extern "C" {static void release_Segment(void *, int);}
static void release_Segment(void *sipCppV, int)
{
    delete reinterpret_cast< ::Segment *>(sipCppV);
}


extern "C" {static void assign_Segment(void *, SIP_SSIZE_T, void *);}
static void assign_Segment(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::Segment *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::Segment *>(sipSrc);
}


extern "C" {static void *array_Segment(SIP_SSIZE_T);}
static void *array_Segment(SIP_SSIZE_T sipNrElem)
{
    return new  ::Segment[sipNrElem];
}


extern "C" {static void *copy_Segment(const void *, SIP_SSIZE_T);}
static void *copy_Segment(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::Segment(reinterpret_cast<const  ::Segment *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_Segment(sipSimpleWrapper *);}
static void dealloc_Segment(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_Segment(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_Segment(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_Segment(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::Segment *sipCpp = 0;

    {
        const  ::std::string* a0;
        int a0State = 0;
        const  ::Joint& a1def = Joint(Joint::None);
        const  ::Joint* a1 = &a1def;
        const  ::Frame& a2def = Frame::Identity();
        const  ::Frame* a2 = &a2def;
        const  ::RigidBodyInertia& a3def = RigidBodyInertia::Zero();
        const  ::RigidBodyInertia* a3 = &a3def;

        static const char *sipKwdList[] = {
            sipName_name,
            sipName_joint,
            sipName_f_tip,
            sipName_I,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J1|J9J9J9", sipType_std_string,&a0, &a0State, sipType_Joint, &a1, sipType_Frame, &a2, sipType_RigidBodyInertia, &a3))
        {
            sipCpp = new  ::Segment(*a0,*a1,*a2,*a3);
            sipReleaseType(const_cast< ::std::string *>(a0),sipType_std_string,a0State);

            return sipCpp;
        }
    }

    {
        const  ::Joint& a0def = Joint(Joint::None);
        const  ::Joint* a0 = &a0def;
        const  ::Frame& a1def = Frame::Identity();
        const  ::Frame* a1 = &a1def;
        const  ::RigidBodyInertia& a2def = RigidBodyInertia::Zero();
        const  ::RigidBodyInertia* a2 = &a2def;

        static const char *sipKwdList[] = {
            sipName_joint,
            sipName_f_tip,
            sipName_I,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|J9J9J9", sipType_Joint, &a0, sipType_Frame, &a1, sipType_RigidBodyInertia, &a2))
        {
            sipCpp = new  ::Segment(*a0,*a1,*a2);

            return sipCpp;
        }
    }

    {
        const  ::Segment* a0;

        static const char *sipKwdList[] = {
            sipName_in,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9", sipType_Segment, &a0))
        {
            sipCpp = new  ::Segment(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's Python slots. */
static sipPySlotDef slots_Segment[] = {
    {(void *)slot_Segment___repr__, repr_slot},
    {0, (sipPySlotType)0}
};


static PyMethodDef methods_Segment[] = {
    {SIP_MLNAME_CAST(sipName_getFrameToTip), meth_Segment_getFrameToTip, METH_VARARGS, SIP_MLDOC_CAST(doc_Segment_getFrameToTip)},
    {SIP_MLNAME_CAST(sipName_getInertia), meth_Segment_getInertia, METH_VARARGS, SIP_MLDOC_CAST(doc_Segment_getInertia)},
    {SIP_MLNAME_CAST(sipName_getJoint), meth_Segment_getJoint, METH_VARARGS, SIP_MLDOC_CAST(doc_Segment_getJoint)},
    {SIP_MLNAME_CAST(sipName_getName), meth_Segment_getName, METH_VARARGS, SIP_MLDOC_CAST(doc_Segment_getName)},
    {SIP_MLNAME_CAST(sipName_pose), (PyCFunction)meth_Segment_pose, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Segment_pose)},
    {SIP_MLNAME_CAST(sipName_setInertia), (PyCFunction)meth_Segment_setInertia, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Segment_setInertia)},
    {SIP_MLNAME_CAST(sipName_twist), (PyCFunction)meth_Segment_twist, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Segment_twist)}
};

PyDoc_STRVAR(doc_Segment, "\1Segment(name: object, joint: Joint = Joint(Joint.None), f_tip: Frame = Frame.Identity(), I: RigidBodyInertia = RigidBodyInertia.Zero())\n"
"Segment(joint: Joint = Joint(Joint.None), f_tip: Frame = Frame.Identity(), I: RigidBodyInertia = RigidBodyInertia.Zero())\n"
"Segment(in_: Segment)");


sipClassTypeDef sipTypeDef_PyKDL_Segment = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_Segment,
        {0},
        0
    },
    {
        sipNameNr_Segment,
        {0, 0, 1},
        7, methods_Segment,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_Segment,
    -1,
    -1,
    0,
    slots_Segment,
    init_type_Segment,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_Segment,
    assign_Segment,
    array_Segment,
    copy_Segment,
    release_Segment,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 81 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/rigidbodyinertia.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 1456 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"

#line 26 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 1463 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"
#line 64 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/rotationalinertia.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 1468 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"
#line 352 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 1474 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"
#line 281 "/home/mars/MarquetteRMC2021/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 1480 "/home/mars/MarquetteRMC2021/ros_catkin_ws/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"


PyDoc_STRVAR(doc_RigidBodyInertia_Zero, "Zero() -> RigidBodyInertia");

extern "C" {static PyObject *meth_RigidBodyInertia_Zero(PyObject *, PyObject *);}
static PyObject *meth_RigidBodyInertia_Zero(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
             ::RigidBodyInertia*sipRes;

            sipRes = new  ::RigidBodyInertia( ::RigidBodyInertia::Zero());

            return sipConvertFromNewType(sipRes,sipType_RigidBodyInertia,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RigidBodyInertia, sipName_Zero, doc_RigidBodyInertia_Zero);

    return NULL;
}


PyDoc_STRVAR(doc_RigidBodyInertia_RefPoint, "RefPoint(self, p: Vector) -> RigidBodyInertia");

extern "C" {static PyObject *meth_RigidBodyInertia_RefPoint(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_RigidBodyInertia_RefPoint(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Vector* a0;
         ::RigidBodyInertia *sipCpp;

        static const char *sipKwdList[] = {
            sipName_p,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_RigidBodyInertia, &sipCpp, sipType_Vector, &a0))
        {
             ::RigidBodyInertia*sipRes;

            sipRes = new  ::RigidBodyInertia(sipCpp->RefPoint(*a0));

            return sipConvertFromNewType(sipRes,sipType_RigidBodyInertia,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RigidBodyInertia, sipName_RefPoint, doc_RigidBodyInertia_RefPoint);

    return NULL;
}


PyDoc_STRVAR(doc_RigidBodyInertia_getMass, "getMass(self) -> float");

extern "C" {static PyObject *meth_RigidBodyInertia_getMass(PyObject *, PyObject *);}
static PyObject *meth_RigidBodyInertia_getMass(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::RigidBodyInertia *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_RigidBodyInertia, &sipCpp))
        {
            double sipRes;

            sipRes = sipCpp->getMass();

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RigidBodyInertia, sipName_getMass, doc_RigidBodyInertia_getMass);

    return NULL;
}


PyDoc_STRVAR(doc_RigidBodyInertia_getCOG, "getCOG(self) -> Vector");

extern "C" {static PyObject *meth_RigidBodyInertia_getCOG(PyObject *, PyObject *);}
static PyObject *meth_RigidBodyInertia_getCOG(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::RigidBodyInertia *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_RigidBodyInertia, &sipCpp))
        {
             ::Vector*sipRes;

            sipRes = new  ::Vector(sipCpp->getCOG());

            return sipConvertFromNewType(sipRes,sipType_Vector,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RigidBodyInertia, sipName_getCOG, doc_RigidBodyInertia_getCOG);

    return NULL;
}


PyDoc_STRVAR(doc_RigidBodyInertia_getRotationalInertia, "getRotationalInertia(self) -> RotationalInertia");

extern "C" {static PyObject *meth_RigidBodyInertia_getRotationalInertia(PyObject *, PyObject *);}
static PyObject *meth_RigidBodyInertia_getRotationalInertia(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::RigidBodyInertia *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_RigidBodyInertia, &sipCpp))
        {
             ::RotationalInertia*sipRes;

            sipRes = new  ::RotationalInertia(sipCpp->getRotationalInertia());

            return sipConvertFromNewType(sipRes,sipType_RotationalInertia,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RigidBodyInertia, sipName_getRotationalInertia, doc_RigidBodyInertia_getRotationalInertia);

    return NULL;
}


extern "C" {static PyObject *slot_RigidBodyInertia___mul__(PyObject *,PyObject *);}
static PyObject *slot_RigidBodyInertia___mul__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
        const  ::RigidBodyInertia* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "dJ9", &a0, sipType_RigidBodyInertia, &a1))
        {
             ::RigidBodyInertia*sipRes;

            sipRes = new  ::RigidBodyInertia((a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_RigidBodyInertia,NULL);
        }
    }

    {
        const  ::RigidBodyInertia* a0;
        const  ::Twist* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_RigidBodyInertia, &a0, sipType_Twist, &a1))
        {
             ::Wrench*sipRes;

            sipRes = new  ::Wrench((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_Wrench,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, mul_slot, NULL, sipArg0, sipArg1);
}


extern "C" {static PyObject *slot_RigidBodyInertia___add__(PyObject *,PyObject *);}
static PyObject *slot_RigidBodyInertia___add__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::RigidBodyInertia* a0;
        const  ::RigidBodyInertia* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_RigidBodyInertia, &a0, sipType_RigidBodyInertia, &a1))
        {
             ::RigidBodyInertia*sipRes;

            sipRes = new  ::RigidBodyInertia((*a0 + *a1));

            return sipConvertFromNewType(sipRes,sipType_RigidBodyInertia,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, add_slot, NULL, sipArg0, sipArg1);
}


/* Call the instance's destructor. */
extern "C" {static void release_RigidBodyInertia(void *, int);}
static void release_RigidBodyInertia(void *sipCppV, int)
{
    delete reinterpret_cast< ::RigidBodyInertia *>(sipCppV);
}


extern "C" {static void assign_RigidBodyInertia(void *, SIP_SSIZE_T, void *);}
static void assign_RigidBodyInertia(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::RigidBodyInertia *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::RigidBodyInertia *>(sipSrc);
}


extern "C" {static void *array_RigidBodyInertia(SIP_SSIZE_T);}
static void *array_RigidBodyInertia(SIP_SSIZE_T sipNrElem)
{
    return new  ::RigidBodyInertia[sipNrElem];
}


extern "C" {static void *copy_RigidBodyInertia(const void *, SIP_SSIZE_T);}
static void *copy_RigidBodyInertia(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::RigidBodyInertia(reinterpret_cast<const  ::RigidBodyInertia *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_RigidBodyInertia(sipSimpleWrapper *);}
static void dealloc_RigidBodyInertia(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_RigidBodyInertia(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_RigidBodyInertia(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_RigidBodyInertia(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::RigidBodyInertia *sipCpp = 0;

    {
        double a0 = 0;
        const  ::Vector& a1def = Vector::Zero();
        const  ::Vector* a1 = &a1def;
        const  ::RotationalInertia& a2def = RotationalInertia::Zero();
        const  ::RotationalInertia* a2 = &a2def;

        static const char *sipKwdList[] = {
            sipName_m,
            sipName_oc,
            sipName_Ic,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|dJ9J9", &a0, sipType_Vector, &a1, sipType_RotationalInertia, &a2))
        {
            sipCpp = new  ::RigidBodyInertia(a0,*a1,*a2);

            return sipCpp;
        }
    }

    {
        const  ::RigidBodyInertia* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_RigidBodyInertia, &a0))
        {
            sipCpp = new  ::RigidBodyInertia(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's Python slots. */
static sipPySlotDef slots_RigidBodyInertia[] = {
    {(void *)slot_RigidBodyInertia___mul__, mul_slot},
    {(void *)slot_RigidBodyInertia___add__, add_slot},
    {0, (sipPySlotType)0}
};


static PyMethodDef methods_RigidBodyInertia[] = {
    {SIP_MLNAME_CAST(sipName_RefPoint), (PyCFunction)meth_RigidBodyInertia_RefPoint, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_RigidBodyInertia_RefPoint)},
    {SIP_MLNAME_CAST(sipName_Zero), meth_RigidBodyInertia_Zero, METH_VARARGS, SIP_MLDOC_CAST(doc_RigidBodyInertia_Zero)},
    {SIP_MLNAME_CAST(sipName_getCOG), meth_RigidBodyInertia_getCOG, METH_VARARGS, SIP_MLDOC_CAST(doc_RigidBodyInertia_getCOG)},
    {SIP_MLNAME_CAST(sipName_getMass), meth_RigidBodyInertia_getMass, METH_VARARGS, SIP_MLDOC_CAST(doc_RigidBodyInertia_getMass)},
    {SIP_MLNAME_CAST(sipName_getRotationalInertia), meth_RigidBodyInertia_getRotationalInertia, METH_VARARGS, SIP_MLDOC_CAST(doc_RigidBodyInertia_getRotationalInertia)}
};

PyDoc_STRVAR(doc_RigidBodyInertia, "\1RigidBodyInertia(m: float = 0, oc: Vector = Vector.Zero(), Ic: RotationalInertia = RotationalInertia.Zero())\n"
"RigidBodyInertia(RigidBodyInertia)");


sipClassTypeDef sipTypeDef_PyKDL_RigidBodyInertia = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_RigidBodyInertia,
        {0},
        0
    },
    {
        sipNameNr_RigidBodyInertia,
        {0, 0, 1},
        5, methods_RigidBodyInertia,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_RigidBodyInertia,
    -1,
    -1,
    0,
    slots_RigidBodyInertia,
    init_type_RigidBodyInertia,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_RigidBodyInertia,
    assign_RigidBodyInertia,
    array_RigidBodyInertia,
    copy_RigidBodyInertia,
    release_RigidBodyInertia,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};
