// Generated by gencpp from file main/RawMicroScanDataMsg.msg
// DO NOT EDIT!


#ifndef MAIN_MESSAGE_RAWMICROSCANDATAMSG_H
#define MAIN_MESSAGE_RAWMICROSCANDATAMSG_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <main/DataHeaderMsg.h>
#include <main/DerivedValuesMsg.h>
#include <main/GeneralSystemStateMsg.h>
#include <main/MeasurementDataMsg.h>
#include <main/IntrusionDataMsg.h>
#include <main/ApplicationDataMsg.h>

namespace main
{
template <class ContainerAllocator>
struct RawMicroScanDataMsg_
{
  typedef RawMicroScanDataMsg_<ContainerAllocator> Type;

  RawMicroScanDataMsg_()
    : header()
    , derived_values()
    , general_system_state()
    , measurement_data()
    , intrusion_data()
    , application_data()  {
    }
  RawMicroScanDataMsg_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , derived_values(_alloc)
    , general_system_state(_alloc)
    , measurement_data(_alloc)
    , intrusion_data(_alloc)
    , application_data(_alloc)  {
  (void)_alloc;
    }



   typedef  ::main::DataHeaderMsg_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef  ::main::DerivedValuesMsg_<ContainerAllocator>  _derived_values_type;
  _derived_values_type derived_values;

   typedef  ::main::GeneralSystemStateMsg_<ContainerAllocator>  _general_system_state_type;
  _general_system_state_type general_system_state;

   typedef  ::main::MeasurementDataMsg_<ContainerAllocator>  _measurement_data_type;
  _measurement_data_type measurement_data;

   typedef  ::main::IntrusionDataMsg_<ContainerAllocator>  _intrusion_data_type;
  _intrusion_data_type intrusion_data;

   typedef  ::main::ApplicationDataMsg_<ContainerAllocator>  _application_data_type;
  _application_data_type application_data;





  typedef boost::shared_ptr< ::main::RawMicroScanDataMsg_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::main::RawMicroScanDataMsg_<ContainerAllocator> const> ConstPtr;

}; // struct RawMicroScanDataMsg_

typedef ::main::RawMicroScanDataMsg_<std::allocator<void> > RawMicroScanDataMsg;

typedef boost::shared_ptr< ::main::RawMicroScanDataMsg > RawMicroScanDataMsgPtr;
typedef boost::shared_ptr< ::main::RawMicroScanDataMsg const> RawMicroScanDataMsgConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::main::RawMicroScanDataMsg_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::main::RawMicroScanDataMsg_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::main::RawMicroScanDataMsg_<ContainerAllocator1> & lhs, const ::main::RawMicroScanDataMsg_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.derived_values == rhs.derived_values &&
    lhs.general_system_state == rhs.general_system_state &&
    lhs.measurement_data == rhs.measurement_data &&
    lhs.intrusion_data == rhs.intrusion_data &&
    lhs.application_data == rhs.application_data;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::main::RawMicroScanDataMsg_<ContainerAllocator1> & lhs, const ::main::RawMicroScanDataMsg_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace main

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::main::RawMicroScanDataMsg_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::main::RawMicroScanDataMsg_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::main::RawMicroScanDataMsg_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::main::RawMicroScanDataMsg_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::main::RawMicroScanDataMsg_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::main::RawMicroScanDataMsg_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::main::RawMicroScanDataMsg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "5fc254cfba77c4b6406f3301d7d54b81";
  }

  static const char* value(const ::main::RawMicroScanDataMsg_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x5fc254cfba77c4b6ULL;
  static const uint64_t static_value2 = 0x406f3301d7d54b81ULL;
};

template<class ContainerAllocator>
struct DataType< ::main::RawMicroScanDataMsg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "main/RawMicroScanDataMsg";
  }

  static const char* value(const ::main::RawMicroScanDataMsg_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::main::RawMicroScanDataMsg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "DataHeaderMsg header\n"
"DerivedValuesMsg derived_values\n"
"GeneralSystemStateMsg general_system_state\n"
"MeasurementDataMsg measurement_data\n"
"IntrusionDataMsg intrusion_data\n"
"ApplicationDataMsg application_data\n"
"\n"
"================================================================================\n"
"MSG: main/DataHeaderMsg\n"
"uint8 version_version\n"
"uint8 version_major_version\n"
"uint8 version_minor_version\n"
"uint8 version_release\n"
"\n"
"uint32 serial_number_of_device\n"
"uint32 serial_number_of_channel_plug\n"
"uint8 channel_number\n"
"\n"
"uint32 sequence_number\n"
"uint32 scan_number\n"
"\n"
"uint16 timestamp_date\n"
"uint32 timestamp_time\n"
"\n"
"================================================================================\n"
"MSG: main/DerivedValuesMsg\n"
"uint16 multiplication_factor\n"
"uint16 number_of_beams\n"
"uint16 scan_time\n"
"float32 start_angle\n"
"float32 angular_beam_resolution\n"
"uint32 interbeam_period\n"
"\n"
"================================================================================\n"
"MSG: main/GeneralSystemStateMsg\n"
"bool run_mode_active\n"
"bool standby_mode_active\n"
"bool contamination_warning\n"
"bool contamination_error\n"
"bool reference_contour_status\n"
"bool manipulation_status\n"
"\n"
"bool[] safe_cut_off_path\n"
"bool[] non_safe_cut_off_path\n"
"bool[] reset_required_cut_off_path\n"
"\n"
"uint8 current_monitoring_case_no_table_1\n"
"uint8 current_monitoring_case_no_table_2\n"
"uint8 current_monitoring_case_no_table_3\n"
"uint8 current_monitoring_case_no_table_4\n"
"\n"
"bool application_error\n"
"bool device_error\n"
"\n"
"================================================================================\n"
"MSG: main/MeasurementDataMsg\n"
"uint32 number_of_beams\n"
"ScanPointMsg[] scan_points\n"
"\n"
"\n"
"================================================================================\n"
"MSG: main/ScanPointMsg\n"
"float32 angle\n"
"uint16 distance\n"
"uint8 reflectivity\n"
"bool valid\n"
"bool infinite\n"
"bool glare\n"
"bool reflector\n"
"bool contamination\n"
"bool contamination_warning\n"
"\n"
"================================================================================\n"
"MSG: main/IntrusionDataMsg\n"
"IntrusionDatumMsg[] data\n"
"\n"
"================================================================================\n"
"MSG: main/IntrusionDatumMsg\n"
"uint32 size\n"
"bool[] flags\n"
"\n"
"================================================================================\n"
"MSG: main/ApplicationDataMsg\n"
"ApplicationInputsMsg inputs\n"
"ApplicationOutputsMsg outputs\n"
"\n"
"================================================================================\n"
"MSG: main/ApplicationInputsMsg\n"
"bool[] unsafe_inputs_input_sources\n"
"bool[] unsafe_inputs_flags\n"
"\n"
"uint16[] monitoring_case_number_inputs\n"
"bool[] monitoring_case_number_inputs_flags\n"
"\n"
"int16 linear_velocity_inputs_velocity_0\n"
"bool linear_velocity_inputs_velocity_0_valid\n"
"bool linear_velocity_inputs_velocity_0_transmitted_safely\n"
"\n"
"int16 linear_velocity_inputs_velocity_1\n"
"bool linear_velocity_inputs_velocity_1_valid\n"
"bool linear_velocity_inputs_velocity_1_transmitted_safely\n"
"\n"
"uint8 sleep_mode_input\n"
"\n"
"\n"
"================================================================================\n"
"MSG: main/ApplicationOutputsMsg\n"
"bool[] evaluation_path_outputs_eval_out\n"
"bool[] evaluation_path_outputs_is_safe\n"
"bool[] evaluation_path_outputs_is_valid\n"
"\n"
"uint16[] monitoring_case_number_outputs \n"
"bool[] monitoring_case_number_outputs_flags\n"
"\n"
"uint8 sleep_mode_output\n"
"bool sleep_mode_output_valid\n"
"\n"
"bool error_flag_contamination_warning\n"
"bool error_flag_contamination_error\n"
"bool error_flag_manipulation_error\n"
"bool error_flag_glare\n"
"bool error_flag_reference_contour_intruded\n"
"bool error_flag_critical_error\n"
"bool error_flags_are_valid\n"
"\n"
"\n"
"int16 linear_velocity_outputs_velocity_0\n"
"bool linear_velocity_outputs_velocity_0_valid\n"
"bool linear_velocity_outputs_velocity_0_transmitted_safely\n"
"\n"
"int16 linear_velocity_outputs_velocity_1\n"
"bool linear_velocity_outputs_velocity_1_valid\n"
"bool linear_velocity_outputs_velocity_1_transmitted_safely\n"
"\n"
"int16[] resulting_velocity\n"
"bool[] resulting_velocity_flags\n"
"\n"
" \n"
;
  }

  static const char* value(const ::main::RawMicroScanDataMsg_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::main::RawMicroScanDataMsg_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.derived_values);
      stream.next(m.general_system_state);
      stream.next(m.measurement_data);
      stream.next(m.intrusion_data);
      stream.next(m.application_data);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct RawMicroScanDataMsg_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::main::RawMicroScanDataMsg_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::main::RawMicroScanDataMsg_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::main::DataHeaderMsg_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "derived_values: ";
    s << std::endl;
    Printer< ::main::DerivedValuesMsg_<ContainerAllocator> >::stream(s, indent + "  ", v.derived_values);
    s << indent << "general_system_state: ";
    s << std::endl;
    Printer< ::main::GeneralSystemStateMsg_<ContainerAllocator> >::stream(s, indent + "  ", v.general_system_state);
    s << indent << "measurement_data: ";
    s << std::endl;
    Printer< ::main::MeasurementDataMsg_<ContainerAllocator> >::stream(s, indent + "  ", v.measurement_data);
    s << indent << "intrusion_data: ";
    s << std::endl;
    Printer< ::main::IntrusionDataMsg_<ContainerAllocator> >::stream(s, indent + "  ", v.intrusion_data);
    s << indent << "application_data: ";
    s << std::endl;
    Printer< ::main::ApplicationDataMsg_<ContainerAllocator> >::stream(s, indent + "  ", v.application_data);
  }
};

} // namespace message_operations
} // namespace ros

#endif // MAIN_MESSAGE_RAWMICROSCANDATAMSG_H
