// Generated by gencpp from file sick_safetyscanners/RawMicroScanDataMsg.msg
// DO NOT EDIT!


#ifndef SICK_SAFETYSCANNERS_MESSAGE_RAWMICROSCANDATAMSG_H
#define SICK_SAFETYSCANNERS_MESSAGE_RAWMICROSCANDATAMSG_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <sick_safetyscanners/DataHeaderMsg.h>
#include <sick_safetyscanners/DerivedValuesMsg.h>
#include <sick_safetyscanners/GeneralSystemStateMsg.h>
#include <sick_safetyscanners/MeasurementDataMsg.h>
#include <sick_safetyscanners/IntrusionDataMsg.h>
#include <sick_safetyscanners/ApplicationDataMsg.h>

namespace sick_safetyscanners
{
template <class ContainerAllocator>
struct RawMicroScanDataMsg_
{
  typedef RawMicroScanDataMsg_<ContainerAllocator> Type;

  RawMicroScanDataMsg_()
    : header()
    , derived_values()
    , general_system_state()
    , measurement_data()
    , intrusion_data()
    , application_data()  {
    }
  RawMicroScanDataMsg_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , derived_values(_alloc)
    , general_system_state(_alloc)
    , measurement_data(_alloc)
    , intrusion_data(_alloc)
    , application_data(_alloc)  {
  (void)_alloc;
    }



   typedef  ::sick_safetyscanners::DataHeaderMsg_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef  ::sick_safetyscanners::DerivedValuesMsg_<ContainerAllocator>  _derived_values_type;
  _derived_values_type derived_values;

   typedef  ::sick_safetyscanners::GeneralSystemStateMsg_<ContainerAllocator>  _general_system_state_type;
  _general_system_state_type general_system_state;

   typedef  ::sick_safetyscanners::MeasurementDataMsg_<ContainerAllocator>  _measurement_data_type;
  _measurement_data_type measurement_data;

   typedef  ::sick_safetyscanners::IntrusionDataMsg_<ContainerAllocator>  _intrusion_data_type;
  _intrusion_data_type intrusion_data;

   typedef  ::sick_safetyscanners::ApplicationDataMsg_<ContainerAllocator>  _application_data_type;
  _application_data_type application_data;





  typedef boost::shared_ptr< ::sick_safetyscanners::RawMicroScanDataMsg_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::sick_safetyscanners::RawMicroScanDataMsg_<ContainerAllocator> const> ConstPtr;

}; // struct RawMicroScanDataMsg_

typedef ::sick_safetyscanners::RawMicroScanDataMsg_<std::allocator<void> > RawMicroScanDataMsg;

typedef boost::shared_ptr< ::sick_safetyscanners::RawMicroScanDataMsg > RawMicroScanDataMsgPtr;
typedef boost::shared_ptr< ::sick_safetyscanners::RawMicroScanDataMsg const> RawMicroScanDataMsgConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::sick_safetyscanners::RawMicroScanDataMsg_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::sick_safetyscanners::RawMicroScanDataMsg_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::sick_safetyscanners::RawMicroScanDataMsg_<ContainerAllocator1> & lhs, const ::sick_safetyscanners::RawMicroScanDataMsg_<ContainerAllocator2> & rhs)
{
  return lhs.header == rhs.header &&
    lhs.derived_values == rhs.derived_values &&
    lhs.general_system_state == rhs.general_system_state &&
    lhs.measurement_data == rhs.measurement_data &&
    lhs.intrusion_data == rhs.intrusion_data &&
    lhs.application_data == rhs.application_data;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::sick_safetyscanners::RawMicroScanDataMsg_<ContainerAllocator1> & lhs, const ::sick_safetyscanners::RawMicroScanDataMsg_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace sick_safetyscanners

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::sick_safetyscanners::RawMicroScanDataMsg_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::sick_safetyscanners::RawMicroScanDataMsg_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::sick_safetyscanners::RawMicroScanDataMsg_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::sick_safetyscanners::RawMicroScanDataMsg_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::sick_safetyscanners::RawMicroScanDataMsg_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::sick_safetyscanners::RawMicroScanDataMsg_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::sick_safetyscanners::RawMicroScanDataMsg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "5fc254cfba77c4b6406f3301d7d54b81";
  }

  static const char* value(const ::sick_safetyscanners::RawMicroScanDataMsg_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x5fc254cfba77c4b6ULL;
  static const uint64_t static_value2 = 0x406f3301d7d54b81ULL;
};

template<class ContainerAllocator>
struct DataType< ::sick_safetyscanners::RawMicroScanDataMsg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "sick_safetyscanners/RawMicroScanDataMsg";
  }

  static const char* value(const ::sick_safetyscanners::RawMicroScanDataMsg_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::sick_safetyscanners::RawMicroScanDataMsg_<ContainerAllocator> >
{
  static const char* value()
  {
    return "DataHeaderMsg header\n"
"DerivedValuesMsg derived_values\n"
"GeneralSystemStateMsg general_system_state\n"
"MeasurementDataMsg measurement_data\n"
"IntrusionDataMsg intrusion_data\n"
"ApplicationDataMsg application_data\n"
"\n"
"================================================================================\n"
"MSG: sick_safetyscanners/DataHeaderMsg\n"
"uint8 version_version\n"
"uint8 version_major_version\n"
"uint8 version_minor_version\n"
"uint8 version_release\n"
"\n"
"uint32 serial_number_of_device\n"
"uint32 serial_number_of_channel_plug\n"
"uint8 channel_number\n"
"\n"
"uint32 sequence_number\n"
"uint32 scan_number\n"
"\n"
"uint16 timestamp_date\n"
"uint32 timestamp_time\n"
"\n"
"================================================================================\n"
"MSG: sick_safetyscanners/DerivedValuesMsg\n"
"uint16 multiplication_factor\n"
"uint16 number_of_beams\n"
"uint16 scan_time\n"
"float32 start_angle\n"
"float32 angular_beam_resolution\n"
"uint32 interbeam_period\n"
"\n"
"================================================================================\n"
"MSG: sick_safetyscanners/GeneralSystemStateMsg\n"
"bool run_mode_active\n"
"bool standby_mode_active\n"
"bool contamination_warning\n"
"bool contamination_error\n"
"bool reference_contour_status\n"
"bool manipulation_status\n"
"\n"
"bool[] safe_cut_off_path\n"
"bool[] non_safe_cut_off_path\n"
"bool[] reset_required_cut_off_path\n"
"\n"
"uint8 current_monitoring_case_no_table_1\n"
"uint8 current_monitoring_case_no_table_2\n"
"uint8 current_monitoring_case_no_table_3\n"
"uint8 current_monitoring_case_no_table_4\n"
"\n"
"bool application_error\n"
"bool device_error\n"
"\n"
"================================================================================\n"
"MSG: sick_safetyscanners/MeasurementDataMsg\n"
"uint32 number_of_beams\n"
"ScanPointMsg[] scan_points\n"
"\n"
"\n"
"================================================================================\n"
"MSG: sick_safetyscanners/ScanPointMsg\n"
"float32 angle\n"
"uint16 distance\n"
"uint8 reflectivity\n"
"bool valid\n"
"bool infinite\n"
"bool glare\n"
"bool reflector\n"
"bool contamination\n"
"bool contamination_warning\n"
"\n"
"================================================================================\n"
"MSG: sick_safetyscanners/IntrusionDataMsg\n"
"IntrusionDatumMsg[] data\n"
"\n"
"================================================================================\n"
"MSG: sick_safetyscanners/IntrusionDatumMsg\n"
"uint32 size\n"
"bool[] flags\n"
"\n"
"================================================================================\n"
"MSG: sick_safetyscanners/ApplicationDataMsg\n"
"ApplicationInputsMsg inputs\n"
"ApplicationOutputsMsg outputs\n"
"\n"
"================================================================================\n"
"MSG: sick_safetyscanners/ApplicationInputsMsg\n"
"bool[] unsafe_inputs_input_sources\n"
"bool[] unsafe_inputs_flags\n"
"\n"
"uint16[] monitoring_case_number_inputs\n"
"bool[] monitoring_case_number_inputs_flags\n"
"\n"
"int16 linear_velocity_inputs_velocity_0\n"
"bool linear_velocity_inputs_velocity_0_valid\n"
"bool linear_velocity_inputs_velocity_0_transmitted_safely\n"
"\n"
"int16 linear_velocity_inputs_velocity_1\n"
"bool linear_velocity_inputs_velocity_1_valid\n"
"bool linear_velocity_inputs_velocity_1_transmitted_safely\n"
"\n"
"uint8 sleep_mode_input\n"
"\n"
"\n"
"================================================================================\n"
"MSG: sick_safetyscanners/ApplicationOutputsMsg\n"
"bool[] evaluation_path_outputs_eval_out\n"
"bool[] evaluation_path_outputs_is_safe\n"
"bool[] evaluation_path_outputs_is_valid\n"
"\n"
"uint16[] monitoring_case_number_outputs \n"
"bool[] monitoring_case_number_outputs_flags\n"
"\n"
"uint8 sleep_mode_output\n"
"bool sleep_mode_output_valid\n"
"\n"
"bool error_flag_contamination_warning\n"
"bool error_flag_contamination_error\n"
"bool error_flag_manipulation_error\n"
"bool error_flag_glare\n"
"bool error_flag_reference_contour_intruded\n"
"bool error_flag_critical_error\n"
"bool error_flags_are_valid\n"
"\n"
"\n"
"int16 linear_velocity_outputs_velocity_0\n"
"bool linear_velocity_outputs_velocity_0_valid\n"
"bool linear_velocity_outputs_velocity_0_transmitted_safely\n"
"\n"
"int16 linear_velocity_outputs_velocity_1\n"
"bool linear_velocity_outputs_velocity_1_valid\n"
"bool linear_velocity_outputs_velocity_1_transmitted_safely\n"
"\n"
"int16[] resulting_velocity\n"
"bool[] resulting_velocity_flags\n"
"\n"
" \n"
;
  }

  static const char* value(const ::sick_safetyscanners::RawMicroScanDataMsg_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::sick_safetyscanners::RawMicroScanDataMsg_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.derived_values);
      stream.next(m.general_system_state);
      stream.next(m.measurement_data);
      stream.next(m.intrusion_data);
      stream.next(m.application_data);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct RawMicroScanDataMsg_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::sick_safetyscanners::RawMicroScanDataMsg_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::sick_safetyscanners::RawMicroScanDataMsg_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::sick_safetyscanners::DataHeaderMsg_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "derived_values: ";
    s << std::endl;
    Printer< ::sick_safetyscanners::DerivedValuesMsg_<ContainerAllocator> >::stream(s, indent + "  ", v.derived_values);
    s << indent << "general_system_state: ";
    s << std::endl;
    Printer< ::sick_safetyscanners::GeneralSystemStateMsg_<ContainerAllocator> >::stream(s, indent + "  ", v.general_system_state);
    s << indent << "measurement_data: ";
    s << std::endl;
    Printer< ::sick_safetyscanners::MeasurementDataMsg_<ContainerAllocator> >::stream(s, indent + "  ", v.measurement_data);
    s << indent << "intrusion_data: ";
    s << std::endl;
    Printer< ::sick_safetyscanners::IntrusionDataMsg_<ContainerAllocator> >::stream(s, indent + "  ", v.intrusion_data);
    s << indent << "application_data: ";
    s << std::endl;
    Printer< ::sick_safetyscanners::ApplicationDataMsg_<ContainerAllocator> >::stream(s, indent + "  ", v.application_data);
  }
};

} // namespace message_operations
} // namespace ros

#endif // SICK_SAFETYSCANNERS_MESSAGE_RAWMICROSCANDATAMSG_H
